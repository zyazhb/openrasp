{
    "data": {
        "config": {
            "hook.white": {
                "*": [
                    "xxe"
                ],
                "localhost:8090/vulns/005-file-write.php": [
                    "xxe"
                ]
            },
            "log.maxstack": 7,
            "security.weak_passwords": []
        },
        "config_time": 1578540398810729967,
        "plugin": {
            "id": "04d39c1bcddf9ec19ae3ca4e775625e5f39fbc83",
            "app_id": "ea74547f9fa31791425b17a594483630d75ab780",
            "name": "official",
            "upload_time": 1580746362119,
            "version": "2020-0202-2230",
            "description": "官方插件",
            "md5": "9243f3a5d88f712cc9408b43b6cb82eb",
            "origin_content": "const plugin_version = '2020-0202-2230'\nconst plugin_name    = 'official'\nconst plugin_desc    = '官方插件'\n\n/*\n * Copyright 2017-2021 Baidu Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// 常用链接\n//\n// Web 攻击检测能力说明、零规则检测算法介绍\n// https://rasp.baidu.com/doc/usage/web.html\n//\n// CVE 漏洞覆盖说明\n// https://rasp.baidu.com/doc/usage/cve.html\n\n'use strict'\nvar plugin  = new RASP(plugin_name)\n\n// 检测逻辑开关\n//\n// block  -> 拦截，并打印报警日志\n// log    -> 打印日志，不拦截\n// ignore -> 关闭这个算法\n\n// BEGIN ALGORITHM CONFIG //\n\nvar algorithmConfig = {\n    // 快速设置\n    meta: {\n        // 若 all_log 开启，表示为观察模式，会将所有的 block 都改为 log\n        all_log: true,\n\n        // 若 is_dev 开启，表示为线下环境，将开启更多消耗性能的检测算法\n        is_dev:  false,\n\n        // schema 版本\n        schema_version: 1\n    },\n\n    // SQL注入算法#1 - 匹配用户输入\n    // 1. 用户输入长度至少 8\n    // 2. 用户输入至少包含一个SQL关键词 - 即 pre_filter，[默认关闭]\n    // 3. 用户输入完整的出现在SQL语句中，且会导致SQL语句逻辑发生变化\n    sql_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        min_length: 8,\n        pre_filter: 'select|file|from|;',\n        pre_enable: false,\n        anti_detect_filter: 'add|all|alter|analyze|and|any|as|asc|avg|begin|between|by|case|create|count|delete|desc|do|dumpfile|else|elseif|end|exists|false|file|float|flush|follows|from|group|having|identified|if|in|insert|interval|into|join|last|like|limit|loop|not|null|on|or|order|procedure|regexp|return|rlike|select|then|true|union|update|values|xor',\n        anti_detect_enable: true,\n        lcs_search: false,\n\n        // 是否允许数据库管理器 - 前端直接提交SQL语句\n        allow_full: true\n    },\n    \n    // SQL注入算法#2 - 语句规范\n    sql_policy: {\n        name:    '算法2 - 拦截异常SQL语句',\n        action:  'block',\n\n        // 粗规则 - 为了减少 tokenize 次数，当SQL语句包含一定特征时才进入\n        // 另外，我们只需要处理增删改查的语句，虽然 show 语句也可以报错注入，但是算法2没必要处理\n        pre_filter: ';|\\\/\\\\*|(?:\\\\d{1,2}\\\\s*,\\\\s*){2}|(?:null\\\\s*,\\\\s*){2}|0x[\\\\da-f]{8}|\\\\W(information_schema|outfile|dumpfile|load_file|benchmark|pg_sleep|sleep|is_srvrolemember|updatexml|extractvalue|hex|char|chr|mid|ord|ascii|bin)\\\\W',\n\n        feature: {\n            // 是否禁止多语句执行，select ...; update ...;\n            stacked_query:      false,\n\n            // 是否禁止16进制字符串，select 0x41424344\n            no_hex:             true,\n\n            // 禁止版本号注释，select/*!500001,2,*/3\n            version_comment:    true,\n\n            // 函数黑名单，具体列表见下方，select load_file(...)\n            function_blacklist: true,\n\n            // 敏感函数频次， 具体列表见下方，select chr(123)||chr(123)||chr(123)=chr(123)||chr(123)||chr(123)\n            function_count:     false,\n\n            // 拦截 union select NULL,NULL 或者 union select 1,2,3,4\n            union_null:         true,\n\n            // 是否拦截 into outfile 写文件操作\n            into_outfile:       true,\n\n            // 是否拦截 information_schema 相关读取操作，默认关闭\n            information_schema: false\n        },\n        function_blacklist: {\n            // 文件操作\n            load_file:        true,\n\n            // 时间差注入\n            benchmark:        true,\n            sleep:            true,\n            pg_sleep:         true,\n\n            // 探测阶段\n            is_srvrolemember: true,\n\n            // 报错注入\n            updatexml:        true,\n            extractvalue:     true,\n\n            // 盲注函数，如有误报可删掉一些函数\n            hex:              true,\n            mid:              true,\n            ord:              true,\n            ascii:            true,\n            bin:              true\n        },\n        function_count: {\n            chr:              5,\n            char:             5\n        }\n    },\n\n    sql_exception: {\n        name:      '算法3 - 记录数据库异常',\n        action:    'log',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#sql-exception',\n\n        // error_code 最多允许 100 个，超过直接清空\n        mysql: {\n\t        error_code: [\n\t            // 1045, // Access denied for user 'bae'@'10.10.1.1'\n\t            1060, // Duplicate column name '5.5.60-0ubuntu0.14.04.1'\n\t            1062, // Duplicate entry '::root@localhost::1' for key 'group_key'\n\t            1064, // You have an error in your SQL syntax\n\t            1105, // XPATH syntax error: '~root@localhost~'\n\t            1367, // Illegal non geometric 'user()' value found during parsing\n\t            1690  // DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))'\n\t        ]\n        },\n        pgsql: {\n            error_code: [\n                \"42601\", // normal syntax error\n                \"22P02\", // ERROR:  invalid input syntax for type double precision: \"DATABASE: test1\"\n            ],\n            error_state: [\n                \"42601\", // normal syntax error\n                \"22P02\", // ERROR:  invalid input syntax for type double precision: \"DATABASE: test1\"\n            ]\n        },\n        sqlite: {\n            error_code: [\n                1, // generic error, like syntax error、malformed MATCH expression: [\"3.6.23.1] and other\n            ]\n        },\n        oracle: {\n            error_code: [\n                \"ORA-29257\", // host string unknown\n                \"ORA-20000\", // Oracle Text error\n                \"ORA-00904\", // invalid identifier\n                \"ORA-19202\", // Error occurred in XML processing\n                \"ORA-01756\", // quoted string not properly terminated\n                \"ORA-01740\", // missing double quote in identifier\n                \"ORA-00920\", // invalid relational operator\n                \"ORA-00907\", // missing right parenthesis\n                \"ORA-00911\", // invalid character\n            ]\n        },\n        hsql: {\n            error_code: [\n                -5583, // malformed quoted identifier\n                -5584, // malformed string\n                -5590, // unexpected end of statement\n            ],\n            error_state: [\n                \"42583\", // malformed quoted identifier\n                \"42584\", // malformed string\n                \"42590\", // unexpected end of statement\n            ]\n        },\n        mssql: {\n            error_code: [\n                105, // Unclosed quotation mark after the character string '%.*ls'.\n                245, // Conversion failed when converting the %ls value '%.*ls' to data type %ls.\n            ]\n        },\n        db2: {\n            error_state: [\n                \"42603\", // The string constant beginning with \"'xxx\" does not have an ending string\n            ]\n        }\n    },\n\n    sql_regex: {\n        name:      '算法4 - 正则表达式算法',\n        action:    'ignore',\n        regex:     'union.*select.*from.*information_schema'\n    },\n\n    // SSRF - 来自用户输入，且为内网地址就拦截\n    ssrf_userinput: {\n        name:   '算法1 - 用户输入匹配算法（支持 rebind 检测）',\n        action: 'block'\n    },\n    // SSRF - 是否允许访问 aws metadata\n    ssrf_aws: {\n        name:   '算法2 - 拦截 AWS/Aliyun/GCP metadata 访问',\n        action: 'block'\n    },\n    // SSRF - 是否允许访问 dnslog 地址\n    ssrf_common: {\n        name:    '算法3 - 拦截常见 dnslog 地址',\n        action:  'block',\n        domains: [\n        \t'.vuleye.pw',\n            '.ceye.io',\n            '.exeye.io',\n            '.vcap.me',\n            '.xip.name',\n            '.xip.io',\n            '.sslip.io',\n            '.nip.io',\n            '.burpcollaborator.net',\n            '.tu4.org',\n            '.2xss.cc',\n            '.bxss.me'\n        ]\n    },\n    // SSRF - 是否允许访问混淆后的IP地址\n    ssrf_obfuscate: {\n        name:   '算法4 - 拦截混淆地址',\n        action: 'block'\n    },\n    // SSRF - 禁止使用 curl 读取 file:///etc/passwd、php://filter/XXXX 这样的内容\n    ssrf_protocol: {\n        name:      '算法5 - 拦截 php:// 等异常协议',\n        action:    'block',\n        protocols: [\n            'file',\n            'gopher',\n\n            // python specific\n            'local_file',\n            'local-file',\n\n            // java specific\n            'jar',\n            'netdoc',\n\n            // php specific\n            'dict',\n            'php',\n            'phar',\n            'compress.zlib',\n            'compress.bzip2'\n        ]\n    },\n\n    // 任意文件下载防护 - 来自用户输入\n    readFile_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        lcs_search: false\n    },\n    // 任意文件下载防护 - 使用 file_get_contents 等函数读取 http(s):// 内容（注意，这里不区分是否为内网地址）\n    readFile_userinput_http: {\n        name:   '算法2 - 用户输入匹配算法 + http 协议',\n        action: 'block'\n    },\n    // 任意文件下载防护 - 使用 file_get_contents 等函数读取 file://、php:// 协议\n    readFile_userinput_unwanted: {\n        name:   '算法3 - 拦截 php:// 等异常协议',\n        action: 'block'\n    },\n    // 任意文件下载防护 - 使用 ../../ 跳出 web 目录读取敏感文件\n    readFile_outsideWebroot: {\n        name:      '算法4 - 禁止使用 ../../ 访问web目录以外的文件',\n        action:    'ignore',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#case-out-webroot'\n    },\n    // 任意文件下载防护 - 读取敏感文件，最后一道防线\n    readFile_unwanted: {\n        name:   '算法5 - 文件探针算法',\n        action: 'log'\n    },\n\n    // 写文件操作 - NTFS 流\n    writeFile_NTFS: {\n        name:   '算法1 - 拦截 NTFS ::$DATA 写入操作',\n        action: 'block'\n    },\n    // 写文件操作 - PUT 上传脚本文件 - 无法关联实际上传的文件和写文件操作，暂时注释掉\n    // writeFile_PUT_script: {\n    //     name:   '算法2 - 拦截 PUT 方式上传 php/jsp 等脚本文件',\n    //     action: 'block'\n    // },\n    // 写文件操作 - 脚本文件\n    // https://rasp.baidu.com/doc/dev/official.html#case-file-write\n    writeFile_script: {\n        name:      '算法2 - 拦截 php/jsp 等脚本文件的写入操作',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#case-file-write',\n        action:    'block',\n        userinput:  true,\n        lcs_search: false\n    },\n\n    // 任意文件删除 - 使用 ../跳出目录\n    deleteFile_userinput: {\n        name:      '算法1 - 用户输入匹配，禁止使用 ../ 删除文件',\n        action:    'block',\n        lcs_search: false\n    },\n\n    // 重命名监控 - 将普通文件重命名为webshell，\n    // 案例有 MOVE 方式上传后门、CVE-2018-9134 dedecms v5.7 后台重命名 getshell\n    rename_webshell: {\n        name:   '算法1 - 通过重命名方式获取 WebShell',\n        action: 'block'\n    },\n    // copy_webshell: {\n    //     action: 'block'\n    // },\n\n    // 文件管理器 - 用户输入匹配，仅当直接读取绝对路径时才检测\n    directory_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        lcs_search: false\n    },\n    // 文件管理器 - 反射方式列目录\n    directory_reflect: {\n        name:   '算法2 - 通过反射调用，查看目录内容',\n        action: 'block'\n    },\n    // 文件管理器 - 查看敏感目录\n    directory_unwanted: {\n        name:   '算法3 - 尝试查看敏感目录',\n        action: 'log'\n    },\n\n    // 文件包含 - 用户输入匹配\n    include_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        lcs_search: false\n    },\n    // 文件包含 - 特殊协议\n    include_protocol: {\n        name:   '算法2 - 尝试包含 jar:// 等异常协议',\n        action: 'block',\n        protocols: [\n            'file',\n            'gopher',\n\n            // java specific\n            'jar',\n            'netdoc',\n\n            // php stream\n            'http',\n            'https',\n\n            // php specific\n            'dict',\n            'php',\n            // 'phar',\n            'compress.zlib',\n            'compress.bzip2',\n            'zip',\n            'rar'\n        ]\n    },\n\n    // XXE - 代码安全开关，通过调用相关函数直接禁止外部实体\n    xxe_disable_entity: {\n        name:   '算法1 - 禁止外部实体加载（记录日志等同于完全忽略）',\n        action: 'ignore',\n        clazz:  {\n            // com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl\n            java_dom:   true,\n\n            // org/dom4j/io/SAXReader\n            java_dom4j: true,\n\n            // org/jdom/input/SAXBuilder,org/jdom2/input/SAXBuilder\n            java_jdom:  true,\n\n            // com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl\n            java_sax:   true,\n\n            // javax/xml/stream/XMLInputFactory\n            java_stax:  true\n        }\n    },\n\n    // XXE - 使用 gopher/ftp/dict/.. 等不常见协议访问外部实体\n    xxe_protocol: {\n        name:   '算法2 - 使用 ftp:// 等异常协议加载外部实体',\n        action: 'block',\n        protocols: [\n            'ftp',\n            'dict',\n            'gopher',\n            'jar',\n            'netdoc'\n        ]\n    },\n    // XXE - 使用 file 协议读取内容，可能误报，默认 log\n    xxe_file: {\n        name:      '算法3 - 使用 file:// 协议读取文件',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#case-xxe',\n        action:    'log',\n    },\n\n    // 文件上传 - COPY/MOVE 方式，仅适合 tomcat\n    fileUpload_webdav: {\n        name:   '算法1 - MOVE 方式上传脚本文件',\n        action: 'block'\n    },\n    // 文件上传 - Multipart 方式上传脚本文件\n    fileUpload_multipart_script: {\n        name:   '算法2 - Multipart 方式上传 PHP/JSP 等脚本文件',\n        action: 'block'\n    },\n    // 文件上传 - Multipart 方式上传 HTML/JS 等文件\n    fileUpload_multipart_html: {\n        name:   '算法3 - Multipart 方式上传 HTML/JS 等文件',\n        action: 'ignore'\n    },\n    // 文件上传 - Multipart 方式上传 DLL/EXE 等文件\n    fileUpload_multipart_exe: {\n        name:   '算法3 - Multipart 方式上传 DLL/EXE 等文件',\n        action: 'ignore'\n    },    \n\n    // OGNL 代码执行漏洞\n    ognl_exec: {\n        name:   '算法1 - 执行异常 OGNL 语句',\n        action: 'block'\n    },\n\n    // 命令执行 - java 反射、反序列化，php eval 等方式\n    command_reflect: {\n        name:   '算法1 - 通过反射执行命令，比如反序列化、加密后门',\n        action: 'block'\n    },\n    // 命令注入 - 命令执行后门，或者命令注入\n    command_userinput: {\n        name:       '算法2 - 用户输入匹配算法，包括命令注入检测',\n        action:     'block',\n        min_length: 2\n    },\n    // 命令注入 - 常见命令\n    command_common: {\n        name:    '算法3 - 识别常用渗透命令（探针）',\n        action:  'log',\n        pattern: 'cat.*/etc/passwd|nc.{1,30}-e.{1,100}/bin/(?:ba)?sh|bash\\\\s-.{0,4}i.{1,20}/dev/tcp/|subprocess.call\\\\(.{0,6}/bin/(?:ba)?sh|fsockopen\\\\(.{1,50}/bin/(?:ba)?sh|perl.{1,80}socket.{1,120}open.{1,80}exec\\\\(.{1,5}/bin/(?:ba)?sh|([\\\\|\\\\&`;\\\\x0d\\\\x0a]|$\\\\([^\\\\(]).{0,3}(ping|nslookup|curl|wget|mail).{1,10}[a-zA-Z0-9_\\\\-]{1,15}\\\\.[a-zA-Z0-9_\\\\-]{1,15}'\n    },\n    // 命令执行 - 语法错误和敏感操作\n    command_error: {\n        name:   '算法4 - 查找语法错误和敏感操作',\n        action: 'log',\n        concat_char: [\"|\", \";\"],\n        sensitive_cmd: [\"curl\", \"bash\", \"cat\", \"sh\"],\n        alarm_token: [\"$IFS\", \"${IFS}\", \"'\"]\n    },\n    // 命令执行 - 是否拦截所有命令执行？如果没有执行命令的需求，可以改为 block，最大程度的保证服务器安全\n    command_other: {\n        name:   '算法5 - 记录或者拦截所有命令执行操作',\n        action: 'ignore'\n    },\n\n    // transformer 反序列化攻击\n    deserialization_transformer: {\n        name:   '算法1 - 拦截 transformer 反序列化攻击',\n        action: 'block'\n    },\n\n    // xss 用户输入匹配算法\n    // 1. 当用户输入长度超过15，匹配上标签正则，且出现在响应里，直接拦截\n    // 2. 当用户输入长度超过15，匹配上标签正则这样的参数个数超过 10，判定为扫描攻击，直接拦截（v1.1.2 之后废弃）\n    xss_userinput: {\n        name:   '算法2 - 拦截输出在响应里的反射 XSS',\n        action: 'log',\n\n        filter_regex: \"<![\\\\-\\\\[A-Za-z]|<([A-Za-z]{1,12})[\\\/>\\\\x00-\\\\x20]\",\n        min_length:   15,\n\n        // v1.1.2 之后废弃\n        max_detection_num: 10\n    },\n\n    // php 专有算法\n    xss_echo: {\n        name:   '算法1 - PHP: 禁止直接输出 GPC 参数',\n        action: 'log',\n\n        filter_regex: \"<![\\\\-\\\\[A-Za-z]|<([A-Za-z]{1,12})[\\\/>\\\\x00-\\\\x20]\"\n    },    \n\n    webshell_eval: {\n        name:   '算法1 - 拦截简单的 PHP 中国菜刀后门',\n        action: 'block'\n    },\n\n    webshell_command: {\n        name:   '算法2 - 拦截简单的 PHP 命令执行后门',\n        action: 'block'\n    },\n\n    webshell_file_put_contents: {\n        name:   '算法3 - 拦截简单的 PHP 文件上传后门',\n        action: 'block'\n    },\n\n    webshell_callable: {\n        name:   '算法4 - 拦截简单的 PHP array_map/walk/filter 后门',\n        action: 'block',\n        functions: [\n            'system', 'exec', 'passthru', 'proc_open', 'shell_exec', 'popen', 'pcntl_exec', 'assert'\n        ]\n    },\n\n    webshell_ld_preload: {\n        name:   '算法5 - 拦截 PHP LD_PRELOAD 机制后门',\n        action: 'block'\n    },\n\n    eval_regex: {\n        name:   '算法1 - 正则表达式',\n        action: 'ignore',\n        regex:  'base64_decode|gzuncompress|create_function'\n    },\n\n    loadLibrary_unc: {\n        name:   '算法1 - 拦截 UNC 路径类库加载',\n        action: 'block'\n    },\n\n    // loadLibrary_other: {\n    //     name:   '算法2 - 记录或者拦截所有类库加载',\n    //     action: 'ignore'\n    // },\n\n    response_dataLeak: {\n        name:   '算法1 - 检查响应里是否有身份证等敏感信息（不建议开启拦截）',\n        action: 'log',\n\n        // 检查类型\n        kind: {\n            phone:         true,\n            identity_card: true,\n            bank_card:     true\n        },\n\n        // Content-Type 过滤\n        content_type: 'html|json|xml'\n    }\n}\n\n// END ALGORITHM CONFIG //\n\n// 配置挂载到全局 RASP 变量\nRASP.algorithmConfig = algorithmConfig\n\nconst clean = {\n    action:     'ignore',\n    message:    'Looks fine to me',\n    confidence: 0\n}\n\nvar forcefulBrowsing = {\n    dotFiles: /\\.(7z|tar|gz|bz2|xz|rar|zip|sql|db|sqlite)$/,\n    nonUserDirectory: /^\/(proc|sys|root)/,\n\n    // webdav 文件探针 - 最常被下载的文件\n    unwantedFilenames: [\n        // user files\n        '.DS_Store',\n        'id_rsa', 'id_rsa.pub', 'known_hosts', 'authorized_keys',\n        '.bash_history', '.csh_history', '.zsh_history', '.mysql_history',\n\n        // project files\n        '.htaccess', '.user.ini',\n\n        'web.config', 'web.xml', 'build.property.xml', 'bower.json',\n        'Gemfile', 'Gemfile.lock',\n        '.gitignore',\n        'error_log', 'error.log', 'nohup.out',\n    ],\n\n    // 目录探针 - webshell 查看频次最高的目录\n    unwantedDirectory: [\n        '/',\n        '/home',\n        '/var/log',\n        '/private/var/log',\n        '/proc',\n        '/sys',\n        'C:\\\\',\n        'D:\\\\',\n        'E:\\\\'\n    ],\n\n    // 文件探针 - webshell 查看频次最高的文件\n    absolutePaths: [\n\t    '/etc/issue',\n        '/etc/shadow',\n        '/etc/passwd',\n        '/etc/hosts',\n        '/etc/apache2/apache2.conf',\n        '/root/.bash_history',\n        '/root/.bash_profile',\n        'c:\\\\windows\\\\system32\\\\inetsrv\\\\metabase.xml',\n        'c:\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts'\n    ]\n}\n\n// 指定检测header注入时检测的header名, 统一使用小写\nvar headerInjection = [\"user-agent\", \"referer\", \"x-forwarded-for\"]\n\n// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名\nvar scriptFileRegex = /\\.(aspx?|jspx?|php[345]?|phtml|sh|py|pl|rb)\\.?$/i\n\n// 正常文件\nvar cleanFileRegex  = /\\.(jpg|jpeg|png|gif|bmp|txt|rar|zip)$/i\n\n// 匹配 HTML/JS 等可以用于钓鱼、domain-fronting 的文件\nvar htmlFileRegex   = /\\.(htm|html|js)$/i\n\n// 匹配 EXE/DLL 等可以执行的文件\nvar exeFileRegex    = /\\.(exe|dll|scr|vbs|cmd|bat)$/i\n\n// 其他的 stream 都没啥用\nvar ntfsRegex       = /::\\$(DATA|INDEX)$/\n\n// 已知用户输入匹配算法误报: 传入 1,2,3,4 -> IN(1,2,3,4)\nvar commaNumRegex   = /^[0-9, ]+$/\n\n// SQL注入算法1 - 预过滤正则\nvar sqliPrefilter1  = new RegExp(algorithmConfig.sql_userinput.pre_filter, 'i')\n\n// SQL注入算法1 - 反探测正则\nvar sqliAntiDetect = new RegExp(algorithmConfig.sql_userinput.anti_detect_filter, 'i')\n\n// SQL注入算法2 - 预过滤正则\nvar sqliPrefilter2  = new RegExp(algorithmConfig.sql_policy.pre_filter, 'i')\n\n// 命令执行探针 - 常用渗透命令\nvar cmdPostPattern  = new RegExp(algorithmConfig.command_common.pattern, 'i')\n\n// 敏感信息泄露 - Content Type 正则\nvar dataLeakContentType = new RegExp(algorithmConfig.response_dataLeak.content_type, 'i')\n\nif (! RASP.is_unittest)\n{\n   // 记录日志模式: 将所有 block 改为 log\n   if (algorithmConfig.meta.all_log)\n   {\n        Object.keys(algorithmConfig).forEach(function (name) {\n            // XXE 外部实体开关不受影响\n            if (name != 'xxe_disable_entity')\n            {\n                if (algorithmConfig[name].action == 'block') \n                {\n                    algorithmConfig[name].action = 'log'\n                }\n            }\n        })\n    }\n\n    // 研发模式: \n    // 1. 开启更多消耗性能的检测算法\n    // 2. 非攻击情况，检测到漏洞也报警\n    if (algorithmConfig.meta.is_dev) \n    {\n        // 关闭 select 预过滤正则\n        algorithmConfig.sql_userinput.pre_enable = false\n\n        // 关闭 1,2,3 误报过滤\n        commaNumRegex = /^$/\n\n        // 关闭 xss_echo 非攻击过滤\n        algorithmConfig.xss_echo.filter_regex = \"\"\n    }\n}\nelse {\n    algorithmConfig.eval_regex.action = \"log\"\n}\n\n// 校验 sql_regex 正则是否合法\nif (algorithmConfig.sql_regex.action != 'ignore') {\n    if (! algorithmConfig.sql_regex.regex.trim()) {\n        plugin.log (\"algorithmConfig.sql_regex.regex is empty, algorithm disabled\")\n        algorithmConfig.sql_regex.action = 'ignore'\n    } else {\n        try {\n            new RegExp(algorithmConfig.sql_regex)\n        } catch (e) {\n            plugin.log (\"Invalid regex in algorithmConfig.sql_regex.regex: \", e)\n            algorithmConfig.sql_regex.action = 'ignore'\n        } \n    }\n}\n\n// 校验 eval_regex 正则是否合法\nif (algorithmConfig.eval_regex.action != 'ignore') {\n    if (! algorithmConfig.eval_regex.regex.trim()) {\n        plugin.log (\"algorithmConfig.eval_regex.regex is empty, algorithm disabled\")\n        algorithmConfig.eval_regex.action = 'ignore'\n    } else {\n        try {\n            new RegExp(algorithmConfig.eval_regex)\n        } catch (e) {\n            plugin.log (\"Invalid regex in algorithmConfig.eval_regex.regex: \", e)\n            algorithmConfig.eval_regex.action = 'ignore'\n        } \n    }\n}\n\n\n// 常用函数\nString.prototype.replaceAll = function(token, tokenValue, maxLength) {\n    if (maxLength === undefined) {\n        maxLength = 4096\n    }\n    // 空值判断，防止死循环\n    if (! token || token.length == 0 || this.length > maxLength) {\n        return this\n    }\n\n    var index  = 0;\n    var string = this;\n\n    do {\n        string = string.replace(token, tokenValue);\n    } while((index = string.indexOf(token, index)) > -1);\n\n    return string\n}\n\n// function canonicalPath (path) {\n//     return path.replaceAll('/./', '/').replaceAll('//', '/').replaceAll('//', '/')\n// }\n\n// 我们不再需要简化路径，当出现两个 /../ 或者两个 \\..\\ 就可以判定为路径遍历攻击了，e.g\n// /./././././home/../../../../etc/passwd\n// \\\\..\\\\..\\\\..\n// \/..\/..\/..\nfunction has_traversal (path) {\n\n    // 左右斜杠，一视同仁\n    var path2 = \"/\" + path.replaceAll('\\\\', '/') + \"/\"\n    // 覆盖 ../../\n    // 以及 /../../\n    var left  = path2.indexOf('/../')\n    var right = path2.lastIndexOf('/../')\n\n    if (left != -1 && right != -1 && left != right)\n    {\n        return true\n    }\n\n    return false\n}\n\n// 判断参数是否包含路径穿越，比path更严格\nfunction param_has_traversal (param) {\n    // 左右斜杠，一视同仁\n    var path = \"/\" + param.replaceAll('\\\\', '/') + \"/\"\n\n    if (path.indexOf(\"/../\") != -1)\n    {\n        return true\n    }\n    return false\n}\n\nfunction is_hostname_dnslog(hostname) {\n    var domains = algorithmConfig.ssrf_common.domains\n\n    if (hostname == 'requestb.in' || hostname == 'transfer.sh')\n    {\n        return true\n    }\n\n    for (var i = 0; i < domains.length; i ++)\n    {\n        if (hostname.endsWith(domains[i]))\n        {\n            return true\n        }\n    }\n\n    return false\n}\n\n// function basename (path) {\n//     // 简单处理，同时支持 windows/linux\n//     var path2 = path.replaceAll('\\\\', '/')\n//     var idx   = path2.lastIndexOf('/')\n//     return path.substr(idx + 1)\n// }\n\n// function has_file_extension(path) {\n//     var filename = basename(path)\n//     var index    = filename.indexOf('.')\n\n//     if (index > 0 && index != filename.length - 1) {\n//         return true\n//     }\n\n//     return false\n// }\n\nfunction validate_stack_php(stacks) {\n    var verdict = false\n\n    for (var i = 0; i < stacks.length; i ++) {\n        var stack = stacks[i]\n\n        // 来自 eval/assert/create_function/...\n        if (stack.indexOf('eval()\\'d code') != -1\n            || stack.indexOf('runtime-created function') != -1\n            || stack.indexOf('assert code@') != -1\n            || stack.indexOf('regexp code@') != -1) {\n            verdict = true\n            break\n        }\n\n        // call_user_func/call_user_func_array 两个函数调用很频繁\n        // 必须是 call_user_func 直接调用 system/exec 等函数才拦截，否则会有很多误报\n        if (stack.indexOf('@call_user_func') != -1) {\n            if (i <= 1) {\n                verdict = true\n                break\n            }\n        }\n    }\n\n    return verdict\n}\n\nfunction is_absolute_path(path, is_windows) {\n\n    // Windows - C:\\\\windows\n    if (is_windows) {\n\n        if (path[1] == ':')\n        {\n            var drive = path[0].toLowerCase()\n            if (drive >= 'a' && drive <= 'z')\n            {\n                return true\n            }\n        }\n    }\n\n    // Unices - /root/\n    return path[0] === '/'\n}\n\nfunction is_outside_webroot(appBasePath, realpath, path) {\n    var verdict = false\n\n    // 如果指定path 为 null 则不校验目录穿越\n    if (path == null || has_traversal(path)) {\n        // servlet 3.X 之后可能会获取不到 appBasePath，或者为空\n        // 提前加个判断，防止因为bug导致误报\n        if (! appBasePath || appBasePath.length == 0) {\n            verdict = false\n        }\n        else if (realpath.indexOf(appBasePath) == -1) {\n            verdict = true\n        }\n    }\n\n    return verdict\n}\n\n// 路径是否来自用户输入\n// file_get_contents(\"/etc/passwd\");\n// file_get_contents(\"../../../../../../../etc/passwd\");\n//\n// 或者以用户输入结尾\n// file_get_contents(\"/data/uploads/\" . \"../../../../../../../etc/passwd\");\nfunction is_path_endswith_userinput(parameter, target, realpath, is_windows, is_lcs_search)\n{\n    var verdict = false\n\n    Object.keys(parameter).some(function (key) {\n        // 只处理非数组、hash情况\n        Object.values(parameter[key]).some(function (value){\n            // 只处理字符串类型的\n            if (typeof value != 'string') {\n                return\n            }\n            // 如果应用做了特殊处理， 比如传入 file:///etc/passwd，实际看到的是 /etc/passwd\n            if (value.startsWith('file://') && \n                is_absolute_path(target, is_windows) && \n                value.endsWith(target)) \n            {\n                verdict = true\n                return true\n            }\n\n            // 去除多余/ 和 \\ 的路径\n            var simplifiedValue\n            var simplifiedTarget\n\n            // Windows 下面\n            // 传入 ../../../conf/tomcat-users.xml\n            // 看到 c:\\tomcat\\webapps\\root\\..\\..\\conf\\tomcat-users.xml\n            if (is_windows) {\n                value = value.replaceAll('/', '\\\\')\n                target = target.replaceAll('/', '\\\\')\n                realpath = realpath.replaceAll('/', '\\\\')\n                simplifiedTarget = target.replaceAll('\\\\\\\\','\\\\')\n                simplifiedValue = value.replaceAll('\\\\\\\\','\\\\')\n            } else{\n                simplifiedTarget = target.replaceAll('//','/')\n                simplifiedValue = value.replaceAll('//','/')\n            }\n            var simplifiedValues\n            if ( is_lcs_search ) {\n                simplifiedValues = lcs_search( simplifiedValue, simplifiedTarget )\n            }\n            else {\n                simplifiedValues = [simplifiedValue]\n            }\n            for(var i = 0, len = simplifiedValues.length; i < len; i++) {\n                simplifiedValue = simplifiedValues[i]\n                // 参数必须有跳出目录，或者是绝对路径\n                if ((target.endsWith(value) || simplifiedTarget.endsWith(simplifiedValue))\n                    && (param_has_traversal(value) || value == realpath || simplifiedValue == realpath))\n                {\n                    verdict = true\n                    return true\n                }\n            }\n        })\n        if (verdict){\n            return true\n        }\n    })\n    return verdict\n}\n\n// 检查是否包含用户输入 - 适合目录\nfunction is_path_containing_userinput(parameter, target, is_windows, is_lcs_search)\n{\n    var verdict = false\n    if (is_windows) {\n        target = target.replaceAll('/', '\\\\')\n        target = target.replaceAll('\\\\\\\\', '\\\\')\n    }\n    else{\n        target = target.replaceAll('//', '/')\n    }\n\n    Object.keys(parameter).some(function (key) {\n        var values = parameter[key]\n        Object.values(values).some(function(value){\n            // 只处理字符串类型的\n            if (typeof value != 'string') {\n                return\n            }\n            if (is_windows) {\n                value = value.replaceAll('/', '\\\\')\n                value = value.replaceAll('\\\\\\\\', '\\\\')\n            }\n            else {\n                value = value.replaceAll('//', '/')\n            }\n            var values\n            if (is_lcs_search) {\n                values = lcs_search(value, target)\n            }\n            else {\n                // java 下面，传入 /usr/ 会变成 /usr，所以少匹配一个字符\n                if ( value.charAt(value.length - 1) == \"/\" || \n                    value.charAt(value.length - 1) == \"\\\\\" ) {\n                    value = value.substr(0, value.length - 1)\n                }\n                values = [value]\n            }\n            for(var i = 0, len = values.length; i < len; i++) {\n                // 只处理非数组、hash情况\n                if (param_has_traversal(values[i]) && target.indexOf(values[i]) != -1) {\n                    verdict = true\n                    return true\n                }\n            }\n        })\n        if (verdict){\n            return true\n        }\n    })\n    return verdict\n}\n\n// 是否来自用户输入 - 适合任意类型参数\nfunction is_from_userinput(parameter, target)\n{\n    var verdict = false\n    Object.keys(parameter).some(function (key) {\n        var values = parameter[key]\n        Object.values(values).some(function(value){\n            // 只处理非数组、hash情况\n            if (value == target) {\n                verdict = true\n                return true\n            }\n        })\n    })\n    return verdict\n}\n\n// 检查逻辑是否被用户参数所修改\nfunction is_token_changed(raw_tokens, userinput_idx, userinput_length, distance, is_sql)\n{\n    if (is_sql === undefined) {\n        is_sql = false\n    }\n    // 当用户输入穿越了多个token，就可以判定为代码注入，默认为2\n    var start = -1, end = raw_tokens.length, distance = distance || 2\n\n    // 寻找 token 起始点，可以改为二分查找\n    for (var i = 0; i < raw_tokens.length; i++)\n    {\n        if (raw_tokens[i].stop > userinput_idx)\n        {\n            start = i\n            break\n        }\n    }\n\n    // 寻找 token 结束点\n    // 需要返回真实distance, 删除 最多需要遍历 distance 个 token  i < start + distance 条件\n    for (var i = start; i < raw_tokens.length; i++)\n    {\n        if (raw_tokens[i].stop >= userinput_idx + userinput_length)\n        {\n            end = i\n            break\n        }\n    }\n\n    var diff = end - start + 1\n    if (diff >= distance) {\n        if (is_sql && algorithmConfig.sql_userinput.anti_detect_enable && diff < 10) {\n            var non_kw = 0\n            for (var i = start; i <= end; i++) {\n                sqliAntiDetect.test(raw_tokens[i].text) || non_kw ++\n                if (non_kw >= 2) {\n                    return true\n                }\n            }\n            return false\n        }\n        return true\n    }\n    return false\n}\n\n// 查找str1和str2的最长公共子串，返回为所有最长子串组成的数组\nfunction lcs_search(str1, str2){\n    var len1 = str1.length;\n    var len2 = str2.length;\n    var dp_arr = [[],[]]\n    var pre = 1\n    var now = 0\n    var result =0\n    var result_pos = []\n\n    for (var i = 0; i <= len2+1; i ++) {\n        dp_arr[0][i] = 0\n        dp_arr[1][i] = 0\n    }\n    for (var i = 0; i <= len1; i ++) {\n        for (var j = 0; j <= len2; j ++) {\n            if ( i == 0 || j == 0 ){\n                dp_arr[now][j] = 0\n            }\n            else if ( str1[i-1] == str2[j-1] ) {\n                dp_arr[now][j] = dp_arr[pre][j-1] + 1\n                if (dp_arr[now][j] > result){\n                    result = dp_arr[now][j]\n                    result_pos = [i - result]\n                }else if (dp_arr[now][j] == result){\n                    result_pos.push( i - result )\n                }\n            }\n            else {\n                dp_arr[now][j] = 0\n            }\n        }\n        if( now == 0 ){\n            now = 1\n            pre = 0\n        }\n        else {\n            now = 0\n            pre = 1\n        }\n    }\n    var result_pos_set = new Set(result_pos)\n    var result_str = new Set()\n    for (var item of result_pos_set) {\n        result_str.add(str1.substr(item, result))\n    }\n    return Array.from(result_str)\n}\n\n// 从字符串中解析cookie\nfunction get_cookies(cookie_str) {\n    cookie_items = cookie_str.split(';')\n    var result = {}\n    for(i = 0; i < cookie_items.length; i++) {\n        item = cookie_items[i].trim()\n        if (item.length == 0) {\n            continue\n        }\n        else {\n            key_len = item.indexOf(\"=\")\n            if (key_len <= 0) {\n                continue\n            }\n            key = unescape(item.substr(0, key_len))\n            value = unescape(item.substr(key_len + 1))\n            result[key] = value\n        }\n    }\n    return result\n}\n\n// 合并context.parameter中 header、cookie、parameter、json参数， header、cookie的key会被重命名\nfunction get_all_parameter(context) {\n    if (context.get_all_parameter !== undefined) {\n        return context.parameter || {}\n    }\n    context.get_all_parameter = true\n    var key_num = 0\n    var parameter = context.parameter || {}\n    if ( context.header != null) {\n        for (name in context.header) {\n            if ( name.toLowerCase() == \"cookie\") {\n                var cookies = get_cookies(context.header.cookie)\n                for (name in cookies) {\n                    while(\"cookie\" + key_num + \"_\" + name in parameter) {\n                        key_num ++\n                    }\n                    parameter[\"cookie\" + key_num + \"_\" + name] = [cookies[name]]\n                }\n            }\n            else if ( headerInjection.indexOf(name.toLowerCase()) != -1) {\n                while(\"header\" + key_num + \"_\" + name in parameter) {\n                    key_num ++\n                }\n                parameter[\"header\" + key_num + \"_\" + name] = [context.header[name]]\n            }\n        }\n        var jsons = [ [context.json || {}, \"input_json\"] ]\n        while (jsons.length > 0) {\n            var json_arr = jsons.pop()\n            var crt_json_key = json_arr[1]\n            var json_obj = json_arr[0]\n            for (item in json_obj) {\n                if (typeof json_obj[item] == \"string\") {\n                    while(\"json\" + key_num + \"_\" + crt_json_key + \"->\" + item in parameter) {\n                        key_num ++\n                    }\n                    parameter[\"json\" + key_num + \"_\" + crt_json_key + \"->\" + item] = [json_obj[item]]\n                }\n                else if (typeof json_obj[item] == \"object\") {\n                    jsons.push([json_obj[item], crt_json_key + \"->\" + item])\n                }\n            }\n        }\n    }\n    return parameter\n}\n\nfunction check_ssrf(params, context, is_redirect) {\n    var hostname  = params.hostname\n    var url       = params.url\n    var ip        = params.ip\n    var reason    = false\n\n    // 算法1 - 当参数来自用户输入，且为内网IP，判定为SSRF攻击\n    if (algorithmConfig.ssrf_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n        if (is_redirect || is_from_userinput(all_parameter, url))\n        {\n            for (var i=0; i<ip.length; i++) {\n                if (/^(127|10|192\\.168|172\\.(1[6-9]|2[0-9]|3[01]))\\./.test(ip[i]))\n                {\n                    if (!(is_redirect && /^(127|10|192\\.168|172\\.(1[6-9]|2[0-9]|3[01]))\\./.test(params.origin_ip))){\n                        return {\n                            action:     algorithmConfig.ssrf_userinput.action,\n                            message:    _(\"SSRF - Requesting intranet address: %1%\", [ ip[i] ]),\n                            confidence: 100,\n                            algorithm:  'ssrf_userinput'\n                        }\n                    }\n                }\n            }\n            \n            if (hostname == '[::]' || hostname == '::1' || hostname == '0.0.0.0') \n            {\n                return {\n                    action:     algorithmConfig.ssrf_userinput.action,\n                    message:    _(\"SSRF - Requesting intranet address: %1%\", [ hostname ]),\n                    confidence: 100,\n                    algorithm:  'ssrf_userinput'\n                }\n            }\n        }\n    }\n\n    // 算法2 - 检查常见探测域名\n    if (algorithmConfig.ssrf_common.action != 'ignore')\n    {\n        if (is_hostname_dnslog(hostname))\n        {\n            return {\n                action:     algorithmConfig.ssrf_common.action,\n                message:    _(\"SSRF - Requesting known DNSLOG address: %1%\", [hostname]),\n                confidence: 100,\n                algorithm:  'ssrf_common'\n            }\n        }\n    }\n\n    // 算法3 - 检测 AWS/Aliyun/GoogleCloud 私有地址: 拦截IP访问、绑定域名访问两种方式\n    if (algorithmConfig.ssrf_aws.action != 'ignore')\n    {\n        if (ip == '169.254.169.254' || ip == '100.100.100.200'\n            || hostname == '169.254.169.254' || hostname == '100.100.100.200' || hostname == 'metadata.google.internal')\n        {\n            return {\n                action:     algorithmConfig.ssrf_aws.action,\n                message:    _(\"SSRF - Requesting AWS metadata address\"),\n                confidence: 100,\n                algorithm:  'ssrf_aws'\n            }\n        }\n    }\n\n    // 算法4 - ssrf_obfuscate\n    //\n    // 检查混淆:\n    // http://2130706433\n    // http://0x7f001\n    //\n    // 以下混淆方式没有检测，容易误报\n    // http://0x7f.0x0.0x0.0x1\n    // http://0x7f.0.0.0\n    if (algorithmConfig.ssrf_obfuscate.action != 'ignore')\n    {\n        var reason = false\n\n        if (!isNaN(hostname) && hostname.length != 0)\n        {\n            reason = _(\"SSRF - Requesting numeric IP address: %1%\", [hostname])\n        }\n        // else if (hostname.startsWith('0x') && hostname.indexOf('.') === -1)\n        // {\n        //     reason = _(\"SSRF - Requesting hexadecimal IP address: %1%\", [hostname])\n        // }\n\n        if (reason)\n        {\n            return {\n                action:     algorithmConfig.ssrf_obfuscate.action,\n                message:    reason,\n                confidence: 100,\n                algorithm:  'ssrf_obfuscate'\n            }\n        }\n    }\n\n    // 算法5 - 特殊协议检查\n    if (algorithmConfig.ssrf_protocol.action != 'ignore')\n    {\n        // 获取协议\n        var proto = url.split(':')[0].toLowerCase()\n\n        if (algorithmConfig.ssrf_protocol.protocols.indexOf(proto) != -1)\n        {\n            return {\n                action:     algorithmConfig.ssrf_protocol.action,\n                message:    _(\"SSRF - Using dangerous protocol: %1%://\", [proto]),\n                confidence: 100,\n                algorithm:  'ssrf_protocol'\n            }\n        }\n    }\n    return false\n}\n\n// 下个版本将会支持翻译，目前还需要暴露一个 getText 接口给插件\nfunction _(message, args) \n{\n    args = args || []\n\n    for (var i = 0; i < args.length; i ++) \n    {\n        var symbol = '%' + (i + 1) + '%'\n        message = message.replace(symbol, args[i])\n    }\n\n    return message\n}\n\n// 开始\n\n// 若开启「研发模式」，将只使用JS插件\nif (! algorithmConfig.meta.is_dev && RASP.get_jsengine() !== 'v8') {\n    // v1.1 之前的版本，SQL/SSRF 使用 java 原生实现，需要将插件配置传递给 java\n    // v1.0 RC1 之前仍然需要使用 RASP.config_set 传递配置\n    if (RASP.config_set) {\n        RASP.config_set('algorithm.config', JSON.stringify(algorithmConfig))\n    }\n    // 用于 v1.0 rhino \n    Object.values = function (obj){\n        var result = Array()\n        for (key in obj) {\n            result.push(obj[key])\n        }\n        return result\n    }\n} else {\n    // 对于PHP + V8，性能还不错，我们保留JS检测逻辑\n    plugin.register('sql', function (params, context) {\n\n        var reason          = false\n        var min_length      = algorithmConfig.sql_userinput.min_length\n        var allow_full      = algorithmConfig.sql_userinput.allow_full\n        var parameters      = context.parameter || {}\n        var json_parameters = context.json || {}\n        var raw_tokens      = []\n\n        function _run(values, name) {\n            var reason = false\n            values.some(function (value) {\n                // 不处理3维及以上的数组\n                if (typeof value != \"string\") {\n                    return false\n                }\n\n                // 最短长度限制\n                if (value.length < min_length) {\n                    return false\n                }\n\n                // 使用lcs查找或直接查找\n                if (algorithmConfig.sql_userinput.lcs_search) {\n                    check_value = lcs_search(params.query, value)\n                }\n                else{\n                    check_value = [value]\n                }\n\n                // 检查用户输入是否存在于SQL中\n                for(var i = 0, len = check_value.length; i < len; i++) {\n                    value = check_value[i]\n                \n                    var userinput_idx = params.query.indexOf(value)\n                    if (userinput_idx == -1) {\n                        return false\n                    }\n\n                    // 如果允许数据库管理器\n                    if (allow_full && params.query.length == value.length)\n                    {\n                        return false\n                    }\n\n                    // 过滤已知误报\n                    // 1,2,3,4,5 -> IN(1,2,3,4,5)\n                    if (commaNumRegex.test(value)) {\n                        return false\n                    }\n\n                    // 预过滤正则，如果开启\n                    if (algorithmConfig.sql_userinput.pre_enable && ! sqliPrefilter1.test(value)) {\n                        return false\n                    }\n\n                    // 懒加载，需要的时候初始化 token\n                    if (raw_tokens.length == 0) {\n                        raw_tokens = RASP.sql_tokenize(params.query, params.server)\n                    }\n\n                    //distance用来屏蔽identifier token解析误报 `dbname`.`table`，请在1.2版本后删除\n                    var distance = 2\n                    if (value.length > 20) {\n                        distance = 3\n                    }\n                    if (is_token_changed(raw_tokens, userinput_idx, value.length, distance, is_sql=true)) {\n                        reason = _(\"SQLi - SQL query structure altered by user input, request parameter name: %1%, value: %2%\", [name, value])\n                        return true\n                    }\n                }\n            })\n            return reason\n        }\n\n        // 算法1: 匹配用户输入，简单识别逻辑是否发生改变\n        if (algorithmConfig.sql_userinput.action != 'ignore') {\n\n            // 匹配 GET/POST/multipart 参数\n            Object.keys(parameters).some(function (name) {\n                // 覆盖场景，后者仅PHP支持\n                // ?id=XXXX\n                // ?data[key1][key2]=XXX\n                var value_list = []\n                Object.values(parameters[name]).forEach(function (value){\n                    if (typeof value == 'string') {\n                        value_list.push(value)\n                    } else {\n                        value_list = value_list.concat(Object.values(value))\n                    }\n                })\n                reason = _run(value_list, name)\n                if (reason) {\n                    return true\n                }\n            })\n\n            // 匹配 header 参数\n            if (reason == false && context.header != null) {\n                Object.keys(context.header).some(function (name) {\n                    if ( name.toLowerCase() == \"cookie\") {\n                        var cookies = get_cookies(context.header.cookie)\n                        for (name in cookies) {\n                            reason = _run([cookies[name]], \"cookie:\" + name)\n                            if (reason) {\n                                return true\n                            }\n                        }\n                    }\n                    else if ( headerInjection.indexOf(name.toLowerCase()) != -1) {\n                        reason = _run([context.header[name]], \"header:\" + name)\n                        if (reason) {\n                            return true\n                        }\n                    }\n                    \n                })\n            }\n\n            // 匹配json参数\n            if (reason == false && Object.keys(json_parameters).length > 0) {\n                var jsons = [ [json_parameters, \"input_json\"] ]\n                while (jsons.length > 0 && reason === false) {\n                    var json_arr = jsons.pop()\n                    var crt_json_key = json_arr[1]\n                    var json_obj = json_arr[0]\n                    for (item in json_obj) {\n                        if (typeof json_obj[item] == \"string\") {\n                            reason = _run([json_obj[item]], crt_json_key + \"->\" + item)\n                            if(reason !== false) {\n                                break;\n                            }\n                        }\n                        else if (typeof json_obj[item] == \"object\") {\n                            jsons.push([json_obj[item], crt_json_key + \"->\" + item])\n                        }\n                    }\n                }\n            }\n\n            if (reason !== false) {\n                return {\n                    action:     algorithmConfig.sql_userinput.action,\n                    confidence: 90,\n                    message:    reason,\n                    algorithm:  'sql_userinput'\n                }\n            }\n        }\n\n        // 算法2: SQL语句策略检查（模拟SQL防火墙功能）\n        if (algorithmConfig.sql_policy.action != 'ignore') {\n\n            // 懒加载，需要时才处理\n            if ((raw_tokens.length == 0) && \n                (sqliPrefilter2.test(params.query))) {\n                raw_tokens = RASP.sql_tokenize(params.query, params.server)\n            }\n\n            var features        = algorithmConfig.sql_policy.feature\n            var func_list       = algorithmConfig.sql_policy.function_blacklist\n            var func_count_list = algorithmConfig.sql_policy.function_count\n\n            // 黑名单函数计数\n            var func_count_arr  = {}\n\n            // 转换小写，避免大小写绕过\n            var tokens_lc = raw_tokens.map(function(v) {\n                return v.text.substr(0, 50).toLowerCase()\n            })\n\n            for (var i = 1; i < tokens_lc.length; i ++)\n            {\n                if (features['union_null'] && tokens_lc[i] === 'select')\n                {\n                    var null_count = 0\n\n                    // 寻找连续的逗号、NULL或者数字\n                    for (var j = i + 1; j < tokens_lc.length && j < i + 6; j ++) {\n                        if (tokens_lc[j] === ',' || tokens_lc[j] == 'null' || ! isNaN(parseInt(tokens_lc[j]))) {\n                            null_count ++\n                        } else {\n                            break\n                        }\n                    }\n\n                    // NULL,NULL,NULL == 5个token\n                    // 1,2,3          == 5个token\n                    if (null_count >= 5) {\n                        reason = _(\"SQLi - Detected UNION-NULL phrase in sql query\")\n                        break\n                    }\n                    continue\n                }\n\n                if (features['stacked_query'] && tokens_lc[i] == ';' && i != tokens_lc.length - 1)\n                {\n                    reason = _(\"SQLi - Detected stacked queries\")\n                    break\n                }\n                else if (features['no_hex'] && tokens_lc[i][0] === '0' && tokens_lc[i][1] === 'x')\n                {\n                    reason = _(\"SQLi - Detected hexadecimal values in sql query\")\n                    break\n                }\n                else if (features['version_comment'] && tokens_lc[i][0] === '/' && tokens_lc[i][1] === '*' && tokens_lc[i][2] === '!')\n                {\n                    reason = _(\"SQLi - Detected MySQL version comment in sql query\")\n                    break\n                }\n                else if (features['function_blacklist'] && i > 0 && tokens_lc[i][0] === '(')\n                {\n                    var func_name = tokens_lc[i - 1]\n                    if (func_list[func_name])\n                    {\n                        reason = _(\"SQLi - Detected dangerous method call %1%() in sql query\", [func_name])\n                        break\n                    }\n\n                    if (features['function_count'] && func_count_list[func_name])\n                    {\n                        if (! func_count_arr[func_name])\n                        {\n                            func_count_arr[func_name] = 1\n                        }\n                        else\n                        {\n                            func_count_arr[func_name] ++\n                        }\n\n                        // 超过次数拦截\n                        if (func_count_arr[func_name] >= func_count_list[func_name]) \n                        {\n                            reason = _(\"SQLi - Detected multiple call to dangerous method %1%() in sql query (%2% times)\", [func_name, func_count_arr[func_name]])\n                            break\n                        }\n                    }\n                }            \n                else if (features['into_outfile'] && i < tokens_lc.length - 2 && tokens_lc[i] == 'into')\n                {\n                    if (tokens_lc[i + 1] == 'outfile' || tokens_lc[i + 1] == 'dumpfile')\n                    {\n                        reason = _(\"SQLi - Detected INTO OUTFILE phrase in sql query\")\n                        break\n                    }\n                }\n                else if (features['information_schema'] && i < tokens_lc.length - 1 && tokens_lc[i] == 'from')\n                {\n                    // `information_schema`.tables\n                    // information_schema  .tables\n                    var part = tokens_lc[i + 1].replaceAll('`', '', 40)\n                    // 正常的antlr和flex返回1个token\n                    if (part == 'information_schema.tables')\n                    {\n                        reason = _(\"SQLi - Detected access to MySQL information_schema.tables table\")\n                        break\n                    }\n                    // flex在1.1.2以前会产生3个token\n                    else if (part == 'information_schema' && i < tokens_lc.length - 3)\n                    {\n                        var part2 = tokens_lc[i + 3].replaceAll('`', '', 10)\n                        if (part2 == \"tables\")\n                        {\n                            reason = _(\"SQLi - Detected access to MySQL information_schema.tables table\")\n                            break\n                        }\n                    }\n                }\n            }\n\n            if (reason !== false) \n            {\n                return {\n                    action:     algorithmConfig.sql_policy.action,\n                    message:    reason,\n                    confidence: 100,\n                    algorithm:  'sql_policy'\n                }\n            }\n        }\n\n        // 算法4: SQL正则表达式\n        if (algorithmConfig.sql_regex.action != 'ignore') {\n            var regex_filter = new RegExp(algorithmConfig.sql_regex.regex, 'i')\n            \n            if (regex_filter.test(params.query)) {\n                return {\n                    action:     algorithmConfig.sql_regex.action,\n                    confidence: 60,\n                    message:    reason,\n                    algorithm:  'sql_regex'\n                }\n            }\n        }\n\n        // 加入缓存，对 prepared sql 特别有效\n        return clean\n    })\n\n    plugin.register('ssrf', function(params, context) {\n        var ret = check_ssrf(params, context, false)\n        if (ret !== false) {\n            return ret\n        }\n        return clean\n    })\n\n    plugin.register('ssrfRedirect', function(params, context) {\n        var params2 = {\n            // 使用原始url，用于检测用户输入\n            url: params.url2,\n            hostname: params.hostname2,\n            ip: params.ip2,\n            ip_origin: params.ip,\n            port: params.port2,\n            function: params.function\n        }\n        var ret2 = check_ssrf(params2, context, true)\n        if (ret2 !== false) {\n            ret = check_ssrf(params, context, false)\n            if (ret === false) {\n                return ret2\n            }\n        }\n        return clean\n    })\n}\n\nplugin.register('sql_exception', function(params, context) {\n    // 为了提高效率，异常代码在 agent 端过滤，插件仅负责过滤掉可能的误报和拼接消息，e.g\n    // mysql error 1367 detected: XXX\n    var error_code = parseInt(params.error_code)\n    var message    = _(\"%1% error %2% detected: %3%\", [params.server, params.error_code, params.error_msg])\n\n    // 1062 Duplicated key 错误会有大量误报问题，仅当语句里包含 rand 字样报警\n    if (error_code == 1062) {\n        // 忽略大小写匹配\n        if ( !/rand/i.test(params.query)) {\n            return clean\n        }\n    }\n\n    else if (error_code == 1064) {\n        if ( /in\\s*\\(\\s*\\)/i.test(params.query)) {\n            return clean\n        }\n    }\n    \n    return {\n        action:     algorithmConfig.sql_exception.action,\n        message:    message,\n        confidence: 70,\n        algorithm:  'sql_exception'\n    }\n})\n\nplugin.register('directory', function (params, context) {\n\n    var realpath    = params.realpath\n    var server      = context.server\n\n    var is_windows  = server.os.indexOf('Windows') != -1\n    var language    = server.language\n\n    // 算法2 - 检查PHP菜刀等后门\n    if (algorithmConfig.directory_reflect.action != 'ignore')\n    {\n        // 目前，只有 PHP 支持通过堆栈方式，拦截列目录功能\n        if (language == 'php' && validate_stack_php(params.stack))\n        {\n            return {\n                action:     algorithmConfig.directory_reflect.action,\n                message:    _(\"WebShell activity - Using file manager function with China Chopper WebShell\"),\n                confidence: 90,\n                algorithm:  'directory_reflect'\n            }\n        }\n    }\n\n    // 算法1 - 用户输入匹配。\n    if (algorithmConfig.directory_userinput.action != 'ignore')\n    {\n       var all_parameter = get_all_parameter(context)\n\n        if (is_path_containing_userinput(all_parameter, params.path, is_windows, algorithmConfig.directory_userinput.lcs_search))\n        {\n            return {\n                action:     algorithmConfig.directory_userinput.action,\n                message:    _(\"Path traversal - Accessing folder specified by userinput, folder is %1%\", [realpath]),\n                confidence: 90,\n                algorithm:  'directory_userinput'\n            }\n        }\n    }\n\n    // 算法3 - 读取敏感目录\n    if (algorithmConfig.directory_unwanted.action != 'ignore')\n    {\n        for (var i = 0; i < forcefulBrowsing.unwantedDirectory.length; i ++) {\n            if (realpath == forcefulBrowsing.unwantedDirectory[i]) {\n                return {\n                    action:     algorithmConfig.directory_unwanted.action,\n                    message:    _(\"WebShell activity - Accessing sensitive folder: %1%\", [realpath]),\n                    confidence: 100,\n                    algorithm:  'directory_unwanted'\n                }\n            }\n        }\n    }\n\n    return clean\n})\n\n\nplugin.register('readFile', function (params, context) {\n    var server    = context.server\n    var is_win    = server.os.indexOf('Windows') != -1\n\n    // weblogic/tongweb 下面，所有war包读取操作全部忽略\n    if (server['server'] === 'weblogic' || server['server'] == 'tongweb')\n    {\n        if (params.realpath.endsWith('.war'))\n        {\n            return clean;\n        }\n    }\n\n    //\n    // 算法1: 简单用户输入识别，拦截任意文件下载漏洞\n    //\n    // 不影响正常操作，e.g\n    // ?path=download/1.jpg\n    //\n    if (algorithmConfig.readFile_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n\n        // ?path=/etc/./hosts\n        // ?path=../../../etc/passwd\n        if (is_path_endswith_userinput(all_parameter, params.path, params.realpath, is_win, algorithmConfig.readFile_userinput.lcs_search))\n        {\n            return {\n                action:     algorithmConfig.readFile_userinput.action,\n                message:    _(\"Path traversal - Downloading files specified by userinput, file is %1%\", [params.realpath]),\n                confidence: 90,\n                algorithm: 'readFile_userinput'\n            }\n        }\n        // @FIXME: 用户输入匹配了两次，需要提高效率\n        if (is_from_userinput(all_parameter, params.path))\n        {\n            // 获取协议，如果有\n            var proto = params.path.split('://')[0].toLowerCase()\n            // 1. 读取 http(s):// 内容\n            // ?file=http://www.baidu.com\n            if (proto === 'http' || proto === 'https')\n            {\n                if (algorithmConfig.readFile_userinput_http.action != 'ignore')\n                {\n                    return {\n                        action:     algorithmConfig.readFile_userinput_http.action,\n                        message:    _(\"SSRF - Requesting http/https resource with file streaming functions, URL is %1%\", [params.path]),\n                        confidence: 90,\n                        algorithm:  'readFile_userinput_http'\n                    }\n                }\n            }\n\n            // 2. 读取特殊协议内容\n            // ?file=file:///etc/passwd\n            // ?file=php://filter/read=convert.base64-encode/resource=XXX\n            if (proto === 'file' || proto === 'php')\n            {\n                if (algorithmConfig.readFile_userinput_unwanted.action != 'ignore')\n                {\n                    return {\n                        action:     algorithmConfig.readFile_userinput_unwanted.action,\n                        message:    _(\"Path traversal - Requesting unwanted protocol %1%://\", [proto]),\n                        confidence: 90,\n                        algorithm:  'readFile_userinput_unwanted'\n                    }\n                }\n            }\n        }\n    }\n\n    //\n    // 算法2: 文件、目录探针\n    // 如果应用读取了列表里的文件，比如 /root/.bash_history，这通常意味着后门操作\n    //\n    if (algorithmConfig.readFile_unwanted.action != 'ignore')\n    {\n        var realpath_lc = params.realpath.toLowerCase()\n        for (var j = 0; j < forcefulBrowsing.absolutePaths.length; j ++) {\n            if (forcefulBrowsing.absolutePaths[j] == realpath_lc) {\n                return {\n                    action:     algorithmConfig.readFile_unwanted.action,\n                    message:    _(\"WebShell activity - Accessing sensitive file %1%\", [params.realpath]),\n                    confidence: 90,\n                    algorithm:  'readFile_unwanted'\n                }\n            }\n        }\n    }\n\n    //\n    // 算法3: 检查文件遍历，看是否超出web目录范围 [容易误报~]\n    //\n    if (algorithmConfig.readFile_outsideWebroot.action != 'ignore')\n    {\n        var path        = params.path\n        var appBasePath = context.appBasePath\n\n        if (is_outside_webroot(appBasePath, params.realpath, path)) {\n            return {\n                action:     algorithmConfig.readFile_outsideWebroot.action,\n                message:    _(\"Path traversal - accessing files outside webroot (%1%), file is %2%\", [appBasePath, params.realpath]),\n                confidence: 90,\n                algorithm:  'readFile_outsideWebroot'\n            }\n        }\n    }\n\n\n    return clean\n})\n\nplugin.register('include', function (params, context) {\n    var url       = params.url\n    var server    = context.server\n    var is_win    = server.os.indexOf('Windows') != -1\n    var realpath  = params.realpath\n\n    // 用户输入检查\n    // ?file=/etc/passwd\n    // ?file=../../../../../var/log/httpd/error.log\n    if (algorithmConfig.include_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n\n        if (is_path_endswith_userinput(all_parameter, url, realpath, is_win, algorithmConfig.include_userinput.lcs_search))\n        {\n            return {\n                action:     algorithmConfig.include_userinput.action,\n                message:    _(\"File inclusion - including files specified by user input\"),\n                confidence: 100,\n                algorithm:  'include_userinput'\n            }\n        }\n    }\n\n    // 如果有协议\n    // include ('http://xxxxx')\n    var items = url.split('://')\n    var proto = items[0].toLowerCase()\n\n    // 特殊协议，\n    // include('file://XXX')\n    // include('php://XXX')\n    if (algorithmConfig.include_protocol.action != 'ignore')\n    {\n        if (algorithmConfig.include_protocol.protocols.indexOf(proto) != -1)\n        {\n            return {\n                action:     algorithmConfig.include_protocol.action,\n                message:    _(\"File inclusion - using unwanted protocol '%1%://' with funtion %2%()\", [proto, params.function]),\n                confidence: 90,\n                algorithm:  'include_protocol'\n            }\n        }\n    }\n\n    return clean\n})\n\nplugin.register('writeFile', function (params, context) {\n\n    // 写 NTFS 流文件，通常是为了绕过限制\n    if (algorithmConfig.writeFile_NTFS.action != 'ignore')\n    {\n        if (ntfsRegex.test(params.realpath))\n        {\n            return {\n                action:     algorithmConfig.writeFile_NTFS.action,\n                message:    _(\"File write - Writing NTFS alternative data streams\", [params.realpath]),\n                confidence: 95,\n                algorithm:  'writeFile_NTFS'\n            }\n        }\n    }\n\n    // PUT 上传脚本文件 - 有个关联问题需要解决，暂时注释掉\n    // if (context.method == 'put' &&\n    //     algorithmConfig.writeFile_PUT_script.action != 'ignore')\n    // {\n    //     if (scriptFileRegex.test(params.realpath))\n    //     {\n    //         return {\n    //             action:     algorithmConfig.writeFile_PUT_script.action,\n    //             message:    _(\"File upload - Using HTTP PUT method to upload a webshell\", [params.realpath]),\n    //             confidence: 95,\n    //             algorithm:  'writeFile_PUT_script'\n    //         }\n    //     }\n    // }\n\n    // 关于这个算法，请参考这个插件定制文档\n    // https://rasp.baidu.com/doc/dev/official.html#case-file-write\n    if (algorithmConfig.writeFile_script.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n        var is_win = context.server.os.indexOf('Windows') != -1\n        if (scriptFileRegex.test(params.realpath))\n        {\n            if (!(algorithmConfig.writeFile_script.userinput) ||\n                ((algorithmConfig.writeFile_script.userinput) &&\n                (is_path_endswith_userinput(all_parameter, params.path, params.realpath, is_win, algorithmConfig.writeFile_script.lcs_search)))\n            ) {\n                return {\n                    action:     algorithmConfig.writeFile_script.action,\n                    message:    _(\"File write - Creating or appending to a server-side script file, file is %1%\", [params.realpath]),\n                    confidence: 85,\n                    algorithm:  'writeFile_script'\n                }\n            }\n        }\n    }\n\n    return clean\n})\n\nplugin.register('deleteFile', function (params, context) {\n\n    if (algorithmConfig.deleteFile_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n        var is_win = context.server.os.indexOf('Windows') != -1\n        if (is_path_endswith_userinput(all_parameter, params.path, params.realpath, is_win, algorithmConfig.deleteFile_userinput.lcs_search)) {\n            return {\n                action:     algorithmConfig.deleteFile_userinput.action,\n                message:    _(\"File delete - Deleting files specified by userinput, file is %1%\", [params.realpath]),\n                confidence: 85,\n                algorithm:  'deleteFile_userinput'\n            }\n        }\n    }\n    return clean\n})\n\n\nplugin.register('fileUpload', function (params, context) {\n\n    // 是否禁止使用 multipart 上传脚本文件，或者 apache/php 服务器配置文件\n    if (algorithmConfig.fileUpload_multipart_script.action != 'ignore')\n    {\n        if (scriptFileRegex.test(params.filename) || ntfsRegex.test(params.filename))\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_script.action,\n                message:    _(\"File upload - Uploading a server-side script file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 95,\n                algorithm:  'fileUpload_multipart_script'\n            }\n        }\n\n        if (params.filename == \".htaccess\" || params.filename == \".user.ini\")\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_script.action,\n                message:    _(\"File upload - Uploading a server-side config file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 95,\n                algorithm:  'fileUpload_multipart_script'\n            }\n        }\n    }\n\n    // 是否禁止 HTML/JS 文件，主要是对抗钓鱼、CORS绕过等问题\n    if (algorithmConfig.fileUpload_multipart_html.action != 'ignore')\n    {\n        if (htmlFileRegex.test(params.filename))\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_html.action,\n                message:    _(\"File upload - Uploading a HTML/JS file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 90,\n                algorithm:  'fileUpload_multipart_html'\n            }\n        }\n    }\n\n    // 是否禁止 EXE/DLL 文件，防止被用于后门下载站点\n    if (algorithmConfig.fileUpload_multipart_exe.action != 'ignore')\n    {\n        if (exeFileRegex.test(params.filename))\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_exe.action,\n                message:    _(\"File upload - Uploading a Executable file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 90,\n                algorithm:  'fileUpload_multipart_exe'\n            }\n        }\n    }\n\n    return clean\n})\n\n\n\nif (algorithmConfig.fileUpload_webdav.action != 'ignore')\n{\n    plugin.register('webdav', function (params, context) {\n\n        // 源文件不是脚本 && 目标文件是脚本，判定为MOVE方式写后门\n        if (! scriptFileRegex.test(params.source) && scriptFileRegex.test(params.dest))\n        {\n            return {\n                action:    algorithmConfig.fileUpload_webdav.action,\n                message:   _(\"File upload - Uploading a server-side script file with HTTP method %1%, file is %2%\", [\n                    context.method, params.dest\n                ]),\n                confidence: 100,\n                algorithm:  'fileUpload_webdav'\n            }\n        }\n\n        return clean\n    })\n}\n\nif (algorithmConfig.rename_webshell.action != 'ignore')\n{\n    plugin.register('rename', function (params, context) {\n        // 目标文件在webroot内才认为是写后门\n        if (!is_outside_webroot(context.appBasePath, params.dest, null)) {\n            // 源文件是干净的文件，目标文件是脚本文件，判定为重命名方式写后门\n            if (cleanFileRegex.test(params.source) && scriptFileRegex.test(params.dest))\n            {\n                return {\n                    action:    algorithmConfig.rename_webshell.action,\n                    message:   _(\"File upload - Renaming a non-script file to server-side script file, source file is %1%\", [\n                        params.source\n                    ]),\n                    confidence: 90,\n                    algorithm:  'rename_webshell'\n                }\n            }\n        }\n\n        return clean\n    })\n}\n\n\nplugin.register('command', function (params, context) {\n    var cmd        = params.command\n    var server     = context.server\n    var message    = undefined\n    var raw_tokens = []\n\n\n    // 算法1: 根据堆栈，检查是否为反序列化攻击。\n    // 理论上，此算法不存在误报\n\n    if (algorithmConfig.command_reflect.action != 'ignore') {\n        // Java 检测逻辑\n        if (server.language == 'java') {\n            var known    = {\n                'com.thoughtworks.xstream.XStream.unmarshal':                                   _(\"Reflected command execution - Using xstream library\"),\n                'java.beans.XMLDecoder.readObject':                                             _(\"Reflected command execution - Using WebLogic XMLDecoder library\"),\n                'org.apache.commons.collections4.functors.InvokerTransformer.transform':        _(\"Reflected command execution - Using Transformer library (v4)\"),\n                'org.apache.commons.collections.functors.InvokerTransformer.transform':         _(\"Reflected command execution - Using Transformer library\"),\n                'org.apache.commons.collections.functors.ChainedTransformer.transform':         _(\"Reflected command execution - Using Transformer library\"),\n                'org.jolokia.jsr160.Jsr160RequestDispatcher.dispatchRequest':                   _(\"Reflected command execution - Using JNDI library (JSR 160)\"),\n                'com.sun.jndi.rmi.registry.RegistryContext.lookup':                             _(\"Reflected command execution - Using JNDI registry service\"),\n                'com.sun.jndi.url.ldap.ldapURLContext.lookup':                                  _(\"Reflected command execution - Using LDAP factory service\"),\n                'com.alibaba.fastjson.JSON.parseObject':                                        _(\"Reflected command execution - Using fastjson library\"),\n                'org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute': _(\"Reflected command execution - Using SpEL expressions\"),\n                'freemarker.template.utility.Execute.exec':                                     _(\"Reflected command execution - Using FreeMarker template\"),\n                'org.jboss.el.util.ReflectionUtil.invokeMethod':                                _(\"Reflected command execution - Using JBoss EL method\"),\n                'net.rebeyond.behinder.payload.java.Cmd.RunCMD':                                _(\"Reflected command execution - Using BeHinder defineClass webshell\"),\n                'org.codehaus.groovy.runtime.ProcessGroovyMethods.execute':                     _(\"Reflected command execution - Using Groovy library\"),\n                'bsh.Reflect.invokeMethod':                                                     _(\"Reflected command execution - Using BeanShell library\"),\n                'jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptFunction.invoke':     _(\"Reflected Command execution - Using Nashorn engine\")\n            }\n\n            var userCode = false, reachedInvoke = false, i = 0\n\n            // v1.1.1 要求在堆栈里过滤 com.baidu.openrasp 相关的类，因为没有实现正确而产生了多余的反射堆栈，这里需要兼容下防止误报\n            // v1.1.2 修复了这个问题，即堆栈顶部为命令执行的方法\n            if (params.stack.length > 3\n                && params.stack[0].startsWith('sun.reflect.GeneratedMethodAccessor')\n                && params.stack[1] == 'sun.reflect.GeneratedMethodAccessorImpl.invoke'\n                && params.stack[2] == 'java.lang.reflect.Method.invoke')\n            {\n                i = 3\n            }\n\n            for (; i < params.stack.length; i ++) {\n                var method = params.stack[i]                \n\n                // 检查反射调用 -> 命令执行之间，是否包含用户代码\n                if (! reachedInvoke) {\n                    if (method == 'java.lang.reflect.Method.invoke') {\n                        reachedInvoke = true\n                    }\n\n                    // 用户代码，即非 JDK、com.baidu.openrasp 相关的函数\n                    if (! method.startsWith('java.') \n                        && ! method.startsWith('sun.') \n                        && !method.startsWith('com.sun.') \n                        && !method.startsWith('com.baidu.openrasp.')) \n                    {\n                        userCode = true\n                    }\n                }\n\n                if (method.startsWith('ysoserial.Pwner')) {\n                    message = _(\"Reflected command execution - Using YsoSerial tool\")\n                    break\n                }\n\n                if (method.startsWith('com.fasterxml.jackson.databind.')) {\n                    message = _(\"Reflected command execution - Using Jackson deserialze method\")\n                    break\n                }\n\n                // 对于如下类型的反射调用:\n                // 1. 仅当命令直接来自反射调用才拦截\n                // 2. 如果某个类是反射生成，这个类再主动执行命令，则忽略\n                if (! userCode) {\n                    if (method == 'ognl.OgnlRuntime.invokeMethod') {\n                        message = _(\"Reflected command execution - Using OGNL library\")\n                        break\n                    }  else if (method == 'java.lang.reflect.Method.invoke') {\n                        message = _(\"Reflected command execution - Unknown vulnerability detected\")\n                        break\n                    }\n                }                                       \n                \n                if (known[method]) {\n                    message = known[method]\n                }\n            }\n        }\n\n        // PHP 检测逻辑\n        else if (server.language == 'php' && validate_stack_php(params.stack))\n        {\n            message = _(\"WebShell activity - Detected reflected command execution\")\n        }\n\n        if (message)\n        {\n            return {\n                action:     algorithmConfig.command_reflect.action,\n                message:    message,\n                confidence: 100,\n                algorithm:  'command_reflect'\n            }\n        }\n    }\n\n    // 从 v0.31 开始，当命令执行来自非HTTP请求的，我们也会检测反序列化攻击\n    // 但是不应该拦截正常的命令执行，所以这里加一个 context.url 检查\n    if (! context.url) {\n        return clean\n    }\n\n    // 算法2: 检测命令注入，或者命令执行后门\n    if (algorithmConfig.command_userinput.action != 'ignore') {\n        var reason     = false\n        var min_length = algorithmConfig.command_userinput.min_length\n        var parameters = context.parameter || {}\n        var json_parameters = context.json || {}\n\n        // 检查命令逻辑是否被用户参数所修改\n        function _run(values, name)\n        {\n            var reason = false\n\n            values.some(function (value) {\n                if (value.length <= min_length) {\n                    return false\n                }\n\n                // 检查用户输入是否存在于命令中\n                var userinput_idx = cmd.indexOf(value)\n                if (userinput_idx == -1) {\n                    return false\n                }\n\n                if (cmd.length == value.length) {\n                    reason = _(\"WebShell detected - Executing command: %1%\", [cmd])\n                    return true\n                }\n                \n                // 懒加载，需要的时候初始化 token\n                if (raw_tokens.length == 0) {\n                    raw_tokens = RASP.cmd_tokenize(cmd)\n                }\n\n                if (is_token_changed(raw_tokens, userinput_idx, value.length)) {\n                    reason = _(\"Command injection - command structure altered by user input, request parameter name: %1%, value: %2%\", [name, value])\n                    return true\n                }\n            })\n\n            return reason\n        }\n\n        // 匹配 GET/POST/multipart 参数\n        Object.keys(parameters).some(function (name) {\n            // 覆盖场景，后者仅PHP支持\n            // ?id=XXXX\n            // ?data[key1][key2]=XXX\n            var value_list = []\n            Object.values(parameters[name]).forEach(function (value){\n                if (typeof value == 'string') {\n                    value_list.push(value)\n                } else {\n                    value_list = value_list.concat(Object.values(value))\n                }\n            })\n            reason = _run(value_list, name)\n            if (reason) {\n                return true\n            }\n        })\n        // 匹配 header 参数\n        if (reason == false && context.header != null) {\n            Object.keys(context.header).some(function (name) {\n                if ( name.toLowerCase() == \"cookie\") {\n                    var cookies = get_cookies(context.header.cookie)\n                    for (name in cookies) {\n                        reason = _run([cookies[name]], \"cookie:\" + name)\n                        if (reason) {\n                            return true\n                        }\n                    }\n                }\n                else if ( headerInjection.indexOf(name.toLowerCase()) != -1) {\n                    reason = _run([context.header[name]], \"header:\" + name)\n                    if (reason) {\n                        return true\n                    }\n                }\n                \n            })\n        }\n\n        // 匹配json参数\n        if (reason == false && Object.keys(json_parameters).length > 0) {\n            var jsons = [ [json_parameters, \"input_json\"] ]\n            while (jsons.length > 0 && reason === false) {\n                var json_arr = jsons.pop()\n                var crt_json_key = json_arr[1]\n                var json_obj = json_arr[0]\n                for (item in json_obj) {\n                    if (typeof json_obj[item] == \"string\") {\n                        reason = _run([json_obj[item]], crt_json_key + \"->\" + item)\n                        if(reason !== false) {\n                            break;\n                        }\n                    }\n                    else if (typeof json_obj[item] == \"object\") {\n                        jsons.push([json_obj[item], crt_json_key + \"->\" + item])\n                    }\n                }\n            }\n        }\n\n        if (reason !== false)\n        {\n            return {\n                action:     algorithmConfig.command_userinput.action,\n                confidence: 90,\n                message:    reason,\n                algorithm:  'command_userinput'\n            }\n        }\n    }\n\n    // 算法3: 常用渗透命令\n    if (algorithmConfig.command_common.action != 'ignore')\n    {\n        var reason = false\n        if (cmdPostPattern.test(params.command))\n        {           \n            return {\n                action:     algorithmConfig.command_common.action,\n                message:    _(\"Webshell detected - Executing potentially dangerous command, command is %1%\", [params.command]),\n                confidence: 95,\n                algorithm:  'command_common'\n            }\n        }     \n    }\n\n    // 算法4: 查找语法错误和敏感操作\n    if (algorithmConfig.command_error.action != 'ignore') {\n        if (raw_tokens.length == 0) {\n            raw_tokens = RASP.cmd_tokenize(cmd)\n        }\n        var concat_char = algorithmConfig.command_error.concat_char\n        var sensitive_cmd = algorithmConfig.command_error.sensitive_cmd\n        var alarm_token = algorithmConfig.command_error.alarm_token\n\n        var double_quote = 0\n        var ticks = 0\n        for (var i=0; i<raw_tokens.length; i++) {\n            if (alarm_token.indexOf(raw_tokens[i].text) != -1) {\n                if ( !(i > 0 && i < raw_tokens.length-1 && raw_tokens[i-1].text == '\"' && raw_tokens[i+1].text == '\"')) {\n                    return {\n                        action:     algorithmConfig.command_error.action,\n                        confidence: 90,\n                        message:    _(\"Command execution - Sensitive command token detect: %1%\", [raw_tokens[i].text]),\n                        algorithm:  'command_error'\n                    }\n                }\n            }\n\n            if (raw_tokens[i+1] !== undefined &&\n                concat_char.indexOf(raw_tokens[i].text) != -1 &&\n                sensitive_cmd.indexOf(raw_tokens[i+1].text) != -1) {\n                return {\n                    action:     algorithmConfig.command_error.action,\n                    confidence: 70,\n                    message:    _(\"Command execution - Sensitive command concat detect: %1% %2%\", [raw_tokens[i].text], raw_tokens[i+1].text),\n                    algorithm:  'command_error'\n                }\n            }\n            if (raw_tokens[i].text == \"\\\"\") {\n                double_quote ++\n            }\n            else if (raw_tokens[i].text == \"`\") {\n                ticks ++\n            }\n        }\n        if (double_quote % 2 != 0) {\n            return {\n                action:     algorithmConfig.command_error.action,\n                confidence: 70,\n                message:    _(\"Command execution - Detected unbalanced double quote!\"),\n                algorithm:  'command_error'\n            }\n        }\n        if (ticks % 2 != 0) {\n            return {\n                action:     algorithmConfig.command_error.action,\n                confidence: 70,\n                message:    _(\"Command execution - Detected unbalanced backtick!\"),\n                algorithm:  'command_error'\n            }\n        }\n    }\n\n    // 算法5: 记录所有的命令执行\n    if (algorithmConfig.command_other.action != 'ignore') \n    {\n        return {\n            action:     algorithmConfig.command_other.action,\n            message:    _(\"Command execution - Logging all command execution by default, command is %1%\", [params.command]),\n            confidence: 90,\n            algorithm:  'command_other'\n        }\n    }\n\n    return clean\n})\n\n\n// 注意: 由于libxml2无法挂钩，所以PHP暂时不支持XXE检测\nplugin.register('xxe', function (params, context) {\n    var server    = context.server\n    var is_win    = server.os.indexOf('Windows') != -1\n    var items     = params.entity.split('://')\n\n    if (algorithmConfig.xxe_protocol.action != 'ignore') {\n        // 检查 windows + SMB 协议，防止泄露 NTLM 信息\n        if (params.entity.startsWith('\\\\\\\\')) {\n            return {\n                action:     algorithmConfig.xxe_protocol.action,\n                message:    _(\"XXE - Using dangerous protocol SMB\"),\n                confidence: 100,\n                algorithm:  'xxe_protocol'\n            }\n        }\n    }\n\n    if (items.length >= 2) {\n        var protocol = items[0].toLowerCase()\n        var address  = items[1]\n\n        // 拒绝特殊协议\n        if (algorithmConfig.xxe_protocol.action != 'ignore') {\n            if (algorithmConfig.xxe_protocol.protocols.indexOf(protocol) != -1) {\n                return {\n                    action:     algorithmConfig.xxe_protocol.action,\n                    message:    _(\"XXE - Using dangerous protocol %1%\", [protocol]),\n                    confidence: 100,\n                    algorithm:  'xxe_protocol'\n                }\n            }\n\n        }\n\n        // file 协议 + 绝对路径, e.g\n        // file:///etc/passwd\n        // file:///etc/passwd?a=1#b=2 (仅Java支持)\n        //\n        // 相对路径容易误报, e.g\n        // file://xwork.dtd\n        if (algorithmConfig.xxe_file.action != 'ignore')\n        {\n            if (address.length > 0 && protocol === 'file' && is_absolute_path(address, is_win) )\n            {\n                var address_lc = address.toLowerCase()\n                \n                // 1.0 Rhino 引擎不支持URL对象，考虑到 1.0 用户不多，先简单处理下\n                try\n                {\n                    var urlObj = new URL(address_lc)\n                    address_lc = urlObj.pathname\n                }\n                catch (e) {}\n\n                // 过滤掉 xml、dtd\n                if (! address_lc.endsWith('.xml') &&\n                    ! address_lc.endsWith('.dtd'))\n                {\n                    return {\n                        action:     algorithmConfig.xxe_file.action,\n                        message:    _(\"XXE - Accessing file %1%\", [address]),\n                        confidence: 90,\n                        algorithm:  'xxe_file'\n                    }\n                }\n            }\n        }\n\n    }\n    return clean\n})\n\n\nif (algorithmConfig.eval_regex.action != 'ignore')\n{\n\t// 算法1: 正则表达式\n    plugin.register('eval', function(params, context) {\n        var regex_filter = new RegExp(algorithmConfig.eval_regex.regex, 'i')\n            \n        if (regex_filter.test(params.code)) {\n\n        \t// 避免 message 太长\n        \tvar code = params.code.substr(0, 50)\n        \tif (params.code.length > 50)\n        \t{\n        \t\tcode = code + ' ...'\n        \t}\n\n            return {\n                action:     algorithmConfig.eval_regex.action,\n                confidence: 60,\n                message:    _(\"Code Execution - Running %1% with %2%() function\", [code, params.function]),\n                algorithm:  'eval_regex'\n            }\n        }\n    })\n}\n\nplugin.register('loadLibrary', function(params, context) {\n\n    if (algorithmConfig.loadLibrary_unc.action != 'ignore') {\n\n        // 仅 windows 需要检查 UNC\n        var is_windows = context.server.os.indexOf('Windows') != -1\n        if (is_windows) {\n            if (params.path.startsWith('\\\\\\\\') || params.path.startsWith('//')) {\n                return {\n                    action:     algorithmConfig.loadLibrary_unc.action,\n                    confidence: 60,\n                    message:    _(\"Load library in UNC path - loading %1% with %2%() function\", [params.path, params.function]),\n                    algorithm:  'loadLibrary_unc'\n                }\n            }    \n        }\n        \n    }\n\n    // if (algorithmConfig.loadLibrary_other.action != 'ignore') {\n    //     return {\n    //         action:     algorithmConfig.loadLibrary_other.action,\n    //         confidence: 60,\n    //         message:    _(\"Load library - logging all by default, library path is %1%\", [params.path]),\n    //         algorithm:  'loadLibrary_other'\n    //     }     \n    // }\n\n    return clean\n})\n\nif (algorithmConfig.ognl_exec.action != 'ignore')\n{\n    // 默认情况下，当OGNL表达式长度超过30才会进入检测点，此长度可配置\n    plugin.register('ognl', function (params, context) {\n\n        // 常见 struts payload 语句特征\n        var ognlPayloads = [\n            'ognl.OgnlContext',\n            'ognl.TypeConverter',\n            'ognl.MemberAccess',\n            '_memberAccess',\n            'ognl.ClassResolver',\n            'java.lang.Runtime',\n            'java.lang.Class',\n            'java.lang.ClassLoader',\n            'java.lang.System',\n            'java.lang.ProcessBuilder',\n            'java.lang.Object',\n            'java.lang.Shutdown',\n            'java.io.File',\n            'javax.script.ScriptEngineManager',\n            'com.opensymphony.xwork2.ActionContext'\n        ]\n\n        var ognlExpression = params.expression\n        for (var index in ognlPayloads)\n        {\n            if (ognlExpression.indexOf(ognlPayloads[index]) > -1)\n            {\n                return {\n                    action:     algorithmConfig.ognl_exec.action,\n                    message:    _(\"OGNL exec - Trying to exploit a OGNL expression vulnerability\"),\n                    confidence: 100,\n                    algorithm:  'ognl_exec'\n                }\n            }\n\n        }\n        return clean\n    })\n}\n\nif (algorithmConfig.deserialization_transformer.action != 'ignore') {\n\n    plugin.register('deserialization', function (params, context) {\n        var deserializationInvalidClazz = [\n            'org.apache.commons.collections.functors.ChainedTransformer.transform',\n            'org.apache.commons.collections.functors.InvokerTransformer',\n            'org.apache.commons.collections.functors.InstantiateTransformer',\n            'org.apache.commons.collections4.functors.InvokerTransformer',\n            'org.apache.commons.collections4.functors.InstantiateTransformer',\n            'org.codehaus.groovy.runtime.ConvertedClosure',\n            'org.codehaus.groovy.runtime.MethodClosure',\n            'org.springframework.beans.factory.ObjectFactory',\n            'xalan.internal.xsltc.trax.TemplatesImpl'\n        ]\n\n        var clazz = params.clazz\n        for (var index in deserializationInvalidClazz) {\n            if (clazz === deserializationInvalidClazz[index]) {\n                return {\n                    action:     algorithmConfig.deserialization_transformer.action,\n                    message:    _(\"Transformer deserialization - unknown deserialize vulnerability detected\"),\n                    confidence: 100,\n                    algorithm:  'deserialization_transformer'\n                }\n            }\n        }\n        return clean\n    })\n}\n\n\n// 匹配身份证\nfunction findFirstIdentityCard(data) {\n    const regexChineseId = /(?<!\\d)\\d{10}(?:[01]\\d)(?:[0123]\\d)\\d{3}(?:\\d|x|X)(?!\\d)/;\n    const W = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\n    const m = regexChineseId.exec(data)\n    if (m) {\n        const id = m[0]\n        let sum = 0;\n        for (let i = 0; i < W.length; i++) {\n            sum += (id[i] - '0') * W[i];\n        }\n        if (id[17] == 'X' || id[17] == 'x') {\n            sum += 10;\n        } else {\n            sum += id[17] - '0';\n        }\n        if (sum % 11 == 1) {\n            return {\n                type:  'Identity Card',\n                match: m[0],\n                parts: data.slice(Math.max(m.index - 40, 0), m.index + m[0].length + 40)\n            }\n        }\n    }\n}\n\n// 匹配手机号\nfunction findFirstMobileNumber(data) {\n    const regexChinesePhone = /(?<!\\d)(?:(?:00|\\+)?86 ?)?(1\\d{2})(?:[ -]?\\d){8}(?!\\d)/;\n    const prefixs = new Set([133, 149, 153, 173, 174, 177, 180,\n        181, 189, 199, 130, 131, 132, 145, 146, 155, 156, 166, 175, 176, 185, 186, 134, 135, 136, 137, 138, 139,\n        147, 148, 150, 151, 152, 157, 158, 159, 165, 178, 182, 183, 184, 187, 188, 198, 170\n    ]);\n    let m = regexChinesePhone.exec(data)\n    if (m) {\n        if (prefixs.has(parseInt(m[1]))) {\n            return {\n                type:  'Mobile Number',\n                match: m[0],\n                parts: data.slice(Math.max(m.index - 40, 0), m.index + m[0].length + 40)\n            }\n        }\n    }\n}\n\n// 匹配银行卡、信用卡\nfunction findFirstBankCard(data) {\n    const regexBankCard = /(?<!\\d)(?:62|3|5[1-5]|4\\d)\\d{2}(?:[ -]?\\d{4}){3}(?!\\d)/;\n    let m = regexBankCard.exec(data)\n    if (m) {\n        let card = m[0].replace(/ |-/g, \"\");\n        let len = card.length;\n        let sum = 0;\n        for (let i = len; i >= 1; i--) {\n            let t = card[len - i] - '0';\n            if (i % 2 == 0) {\n                t *= 2;\n            }\n            sum = sum + Math.floor(t / 10) + t % 10;\n        }\n        if (sum % 10 == 0) {\n            return {\n                type:  'Bank Card',\n                match: m[0],\n                parts: data.slice(Math.max(m.index - 40, 0), m.index + m[0].length + 40)\n            }\n        }\n    }\n}\n\nif (algorithmConfig.response_dataLeak.action != 'ignore') {\n\n    // response 所有检测点都会抽样\n    plugin.register('response', function (params, context) {\n        const content_type = params.content_type\n        const content      = params.content\n        const kind         = algorithmConfig.response_dataLeak.kind\n        const header       = context.header || {}\n\n        var items = [], parts = []\n\n        // content-type 过滤\n        if ( ! content_type && ! dataLeakContentType.test(content_type)) {\n            return clean\n        }\n\n        // 是否检查身份证泄露\n        if (kind.identity_card) {\n            const data = findFirstIdentityCard(content)\n            if (data) {\n                items.push(data.match + '(' + data.type + ')')\n                parts.push(data)\n            }\n        }\n\n        // 是否检查手机号泄露\n        if (kind.phone) {\n            const data = findFirstMobileNumber(content)\n            if (data) {\n                items.push(data.match + '(' + data.type + ')')\n                parts.push(data)\n            }\n        }\n\n        // 是否检查银行卡泄露\n        if (kind.bank_card) {\n            const data = findFirstBankCard(content)\n            if (data) {\n                items.push(data.match + '(' + data.type + ')')\n                parts.push(data)\n            }\n        }\n\n        if (items.length) {\n            return {\n                action:     algorithmConfig.response_dataLeak.action,\n                message:    'PII leak detected: ' + items.join('、 '),\n                confidence: 80,\n                algorithm:  'response_dataLeak',\n                params: {\n                    parts\n                }\n            }\n        }\n    })\n\n}\n\nplugin.log('OpenRASP official plugin: Initialized, version', plugin_version)\n\n",
            "plugin": "const plugin_version = '2020-0202-2230'\nconst plugin_name    = 'official'\nconst plugin_desc    = '官方插件'\n\n/*\n * Copyright 2017-2021 Baidu Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// 常用链接\n//\n// Web 攻击检测能力说明、零规则检测算法介绍\n// https://rasp.baidu.com/doc/usage/web.html\n//\n// CVE 漏洞覆盖说明\n// https://rasp.baidu.com/doc/usage/cve.html\n\n'use strict'\nvar plugin  = new RASP(plugin_name)\n\n// 检测逻辑开关\n//\n// block  -> 拦截，并打印报警日志\n// log    -> 打印日志，不拦截\n// ignore -> 关闭这个算法\n\n// BEGIN ALGORITHM CONFIG //\n\nvar algorithmConfig = {\n    // 快速设置\n    meta: {\n        // 若 all_log 开启，表示为观察模式，会将所有的 block 都改为 log\n        all_log: true,\n\n        // 若 is_dev 开启，表示为线下环境，将开启更多消耗性能的检测算法\n        is_dev:  false,\n\n        // schema 版本\n        schema_version: 1\n    },\n\n    // SQL注入算法#1 - 匹配用户输入\n    // 1. 用户输入长度至少 8\n    // 2. 用户输入至少包含一个SQL关键词 - 即 pre_filter，[默认关闭]\n    // 3. 用户输入完整的出现在SQL语句中，且会导致SQL语句逻辑发生变化\n    sql_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        min_length: 8,\n        pre_filter: 'select|file|from|;',\n        pre_enable: false,\n        anti_detect_filter: 'add|all|alter|analyze|and|any|as|asc|avg|begin|between|by|case|create|count|delete|desc|do|dumpfile|else|elseif|end|exists|false|file|float|flush|follows|from|group|having|identified|if|in|insert|interval|into|join|last|like|limit|loop|not|null|on|or|order|procedure|regexp|return|rlike|select|then|true|union|update|values|xor',\n        anti_detect_enable: true,\n        lcs_search: false,\n\n        // 是否允许数据库管理器 - 前端直接提交SQL语句\n        allow_full: true\n    },\n    \n    // SQL注入算法#2 - 语句规范\n    sql_policy: {\n        name:    '算法2 - 拦截异常SQL语句',\n        action:  'block',\n\n        // 粗规则 - 为了减少 tokenize 次数，当SQL语句包含一定特征时才进入\n        // 另外，我们只需要处理增删改查的语句，虽然 show 语句也可以报错注入，但是算法2没必要处理\n        pre_filter: ';|\\\/\\\\*|(?:\\\\d{1,2}\\\\s*,\\\\s*){2}|(?:null\\\\s*,\\\\s*){2}|0x[\\\\da-f]{8}|\\\\W(information_schema|outfile|dumpfile|load_file|benchmark|pg_sleep|sleep|is_srvrolemember|updatexml|extractvalue|hex|char|chr|mid|ord|ascii|bin)\\\\W',\n\n        feature: {\n            // 是否禁止多语句执行，select ...; update ...;\n            stacked_query:      false,\n\n            // 是否禁止16进制字符串，select 0x41424344\n            no_hex:             true,\n\n            // 禁止版本号注释，select/*!500001,2,*/3\n            version_comment:    true,\n\n            // 函数黑名单，具体列表见下方，select load_file(...)\n            function_blacklist: true,\n\n            // 敏感函数频次， 具体列表见下方，select chr(123)||chr(123)||chr(123)=chr(123)||chr(123)||chr(123)\n            function_count:     false,\n\n            // 拦截 union select NULL,NULL 或者 union select 1,2,3,4\n            union_null:         true,\n\n            // 是否拦截 into outfile 写文件操作\n            into_outfile:       true,\n\n            // 是否拦截 information_schema 相关读取操作，默认关闭\n            information_schema: false\n        },\n        function_blacklist: {\n            // 文件操作\n            load_file:        true,\n\n            // 时间差注入\n            benchmark:        true,\n            sleep:            true,\n            pg_sleep:         true,\n\n            // 探测阶段\n            is_srvrolemember: true,\n\n            // 报错注入\n            updatexml:        true,\n            extractvalue:     true,\n\n            // 盲注函数，如有误报可删掉一些函数\n            hex:              true,\n            mid:              true,\n            ord:              true,\n            ascii:            true,\n            bin:              true\n        },\n        function_count: {\n            chr:              5,\n            char:             5\n        }\n    },\n\n    sql_exception: {\n        name:      '算法3 - 记录数据库异常',\n        action:    'log',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#sql-exception',\n\n        // error_code 最多允许 100 个，超过直接清空\n        mysql: {\n\t        error_code: [\n\t            // 1045, // Access denied for user 'bae'@'10.10.1.1'\n\t            1060, // Duplicate column name '5.5.60-0ubuntu0.14.04.1'\n\t            1062, // Duplicate entry '::root@localhost::1' for key 'group_key'\n\t            1064, // You have an error in your SQL syntax\n\t            1105, // XPATH syntax error: '~root@localhost~'\n\t            1367, // Illegal non geometric 'user()' value found during parsing\n\t            1690  // DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))'\n\t        ]\n        },\n        pgsql: {\n            error_code: [\n                \"42601\", // normal syntax error\n                \"22P02\", // ERROR:  invalid input syntax for type double precision: \"DATABASE: test1\"\n            ],\n            error_state: [\n                \"42601\", // normal syntax error\n                \"22P02\", // ERROR:  invalid input syntax for type double precision: \"DATABASE: test1\"\n            ]\n        },\n        sqlite: {\n            error_code: [\n                1, // generic error, like syntax error、malformed MATCH expression: [\"3.6.23.1] and other\n            ]\n        },\n        oracle: {\n            error_code: [\n                \"ORA-29257\", // host string unknown\n                \"ORA-20000\", // Oracle Text error\n                \"ORA-00904\", // invalid identifier\n                \"ORA-19202\", // Error occurred in XML processing\n                \"ORA-01756\", // quoted string not properly terminated\n                \"ORA-01740\", // missing double quote in identifier\n                \"ORA-00920\", // invalid relational operator\n                \"ORA-00907\", // missing right parenthesis\n                \"ORA-00911\", // invalid character\n            ]\n        },\n        hsql: {\n            error_code: [\n                -5583, // malformed quoted identifier\n                -5584, // malformed string\n                -5590, // unexpected end of statement\n            ],\n            error_state: [\n                \"42583\", // malformed quoted identifier\n                \"42584\", // malformed string\n                \"42590\", // unexpected end of statement\n            ]\n        },\n        mssql: {\n            error_code: [\n                105, // Unclosed quotation mark after the character string '%.*ls'.\n                245, // Conversion failed when converting the %ls value '%.*ls' to data type %ls.\n            ]\n        },\n        db2: {\n            error_state: [\n                \"42603\", // The string constant beginning with \"'xxx\" does not have an ending string\n            ]\n        }\n    },\n\n    sql_regex: {\n        name:      '算法4 - 正则表达式算法',\n        action:    'ignore',\n        regex:     'union.*select.*from.*information_schema'\n    },\n\n    // SSRF - 来自用户输入，且为内网地址就拦截\n    ssrf_userinput: {\n        name:   '算法1 - 用户输入匹配算法（支持 rebind 检测）',\n        action: 'block'\n    },\n    // SSRF - 是否允许访问 aws metadata\n    ssrf_aws: {\n        name:   '算法2 - 拦截 AWS/Aliyun/GCP metadata 访问',\n        action: 'block'\n    },\n    // SSRF - 是否允许访问 dnslog 地址\n    ssrf_common: {\n        name:    '算法3 - 拦截常见 dnslog 地址',\n        action:  'block',\n        domains: [\n        \t'.vuleye.pw',\n            '.ceye.io',\n            '.exeye.io',\n            '.vcap.me',\n            '.xip.name',\n            '.xip.io',\n            '.sslip.io',\n            '.nip.io',\n            '.burpcollaborator.net',\n            '.tu4.org',\n            '.2xss.cc',\n            '.bxss.me'\n        ]\n    },\n    // SSRF - 是否允许访问混淆后的IP地址\n    ssrf_obfuscate: {\n        name:   '算法4 - 拦截混淆地址',\n        action: 'block'\n    },\n    // SSRF - 禁止使用 curl 读取 file:///etc/passwd、php://filter/XXXX 这样的内容\n    ssrf_protocol: {\n        name:      '算法5 - 拦截 php:// 等异常协议',\n        action:    'block',\n        protocols: [\n            'file',\n            'gopher',\n\n            // python specific\n            'local_file',\n            'local-file',\n\n            // java specific\n            'jar',\n            'netdoc',\n\n            // php specific\n            'dict',\n            'php',\n            'phar',\n            'compress.zlib',\n            'compress.bzip2'\n        ]\n    },\n\n    // 任意文件下载防护 - 来自用户输入\n    readFile_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        lcs_search: false\n    },\n    // 任意文件下载防护 - 使用 file_get_contents 等函数读取 http(s):// 内容（注意，这里不区分是否为内网地址）\n    readFile_userinput_http: {\n        name:   '算法2 - 用户输入匹配算法 + http 协议',\n        action: 'block'\n    },\n    // 任意文件下载防护 - 使用 file_get_contents 等函数读取 file://、php:// 协议\n    readFile_userinput_unwanted: {\n        name:   '算法3 - 拦截 php:// 等异常协议',\n        action: 'block'\n    },\n    // 任意文件下载防护 - 使用 ../../ 跳出 web 目录读取敏感文件\n    readFile_outsideWebroot: {\n        name:      '算法4 - 禁止使用 ../../ 访问web目录以外的文件',\n        action:    'ignore',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#case-out-webroot'\n    },\n    // 任意文件下载防护 - 读取敏感文件，最后一道防线\n    readFile_unwanted: {\n        name:   '算法5 - 文件探针算法',\n        action: 'log'\n    },\n\n    // 写文件操作 - NTFS 流\n    writeFile_NTFS: {\n        name:   '算法1 - 拦截 NTFS ::$DATA 写入操作',\n        action: 'block'\n    },\n    // 写文件操作 - PUT 上传脚本文件 - 无法关联实际上传的文件和写文件操作，暂时注释掉\n    // writeFile_PUT_script: {\n    //     name:   '算法2 - 拦截 PUT 方式上传 php/jsp 等脚本文件',\n    //     action: 'block'\n    // },\n    // 写文件操作 - 脚本文件\n    // https://rasp.baidu.com/doc/dev/official.html#case-file-write\n    writeFile_script: {\n        name:      '算法2 - 拦截 php/jsp 等脚本文件的写入操作',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#case-file-write',\n        action:    'block',\n        userinput:  true,\n        lcs_search: false\n    },\n\n    // 任意文件删除 - 使用 ../跳出目录\n    deleteFile_userinput: {\n        name:      '算法1 - 用户输入匹配，禁止使用 ../ 删除文件',\n        action:    'block',\n        lcs_search: false\n    },\n\n    // 重命名监控 - 将普通文件重命名为webshell，\n    // 案例有 MOVE 方式上传后门、CVE-2018-9134 dedecms v5.7 后台重命名 getshell\n    rename_webshell: {\n        name:   '算法1 - 通过重命名方式获取 WebShell',\n        action: 'block'\n    },\n    // copy_webshell: {\n    //     action: 'block'\n    // },\n\n    // 文件管理器 - 用户输入匹配，仅当直接读取绝对路径时才检测\n    directory_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        lcs_search: false\n    },\n    // 文件管理器 - 反射方式列目录\n    directory_reflect: {\n        name:   '算法2 - 通过反射调用，查看目录内容',\n        action: 'block'\n    },\n    // 文件管理器 - 查看敏感目录\n    directory_unwanted: {\n        name:   '算法3 - 尝试查看敏感目录',\n        action: 'log'\n    },\n\n    // 文件包含 - 用户输入匹配\n    include_userinput: {\n        name:       '算法1 - 用户输入匹配算法',\n        action:     'block',\n        lcs_search: false\n    },\n    // 文件包含 - 特殊协议\n    include_protocol: {\n        name:   '算法2 - 尝试包含 jar:// 等异常协议',\n        action: 'block',\n        protocols: [\n            'file',\n            'gopher',\n\n            // java specific\n            'jar',\n            'netdoc',\n\n            // php stream\n            'http',\n            'https',\n\n            // php specific\n            'dict',\n            'php',\n            // 'phar',\n            'compress.zlib',\n            'compress.bzip2',\n            'zip',\n            'rar'\n        ]\n    },\n\n    // XXE - 代码安全开关，通过调用相关函数直接禁止外部实体\n    xxe_disable_entity: {\n        name:   '算法1 - 禁止外部实体加载（记录日志等同于完全忽略）',\n        action: 'ignore',\n        clazz:  {\n            // com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl\n            java_dom:   true,\n\n            // org/dom4j/io/SAXReader\n            java_dom4j: true,\n\n            // org/jdom/input/SAXBuilder,org/jdom2/input/SAXBuilder\n            java_jdom:  true,\n\n            // com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl\n            java_sax:   true,\n\n            // javax/xml/stream/XMLInputFactory\n            java_stax:  true\n        }\n    },\n\n    // XXE - 使用 gopher/ftp/dict/.. 等不常见协议访问外部实体\n    xxe_protocol: {\n        name:   '算法2 - 使用 ftp:// 等异常协议加载外部实体',\n        action: 'block',\n        protocols: [\n            'ftp',\n            'dict',\n            'gopher',\n            'jar',\n            'netdoc'\n        ]\n    },\n    // XXE - 使用 file 协议读取内容，可能误报，默认 log\n    xxe_file: {\n        name:      '算法3 - 使用 file:// 协议读取文件',\n        reference: 'https://rasp.baidu.com/doc/dev/official.html#case-xxe',\n        action:    'log',\n    },\n\n    // 文件上传 - COPY/MOVE 方式，仅适合 tomcat\n    fileUpload_webdav: {\n        name:   '算法1 - MOVE 方式上传脚本文件',\n        action: 'block'\n    },\n    // 文件上传 - Multipart 方式上传脚本文件\n    fileUpload_multipart_script: {\n        name:   '算法2 - Multipart 方式上传 PHP/JSP 等脚本文件',\n        action: 'block'\n    },\n    // 文件上传 - Multipart 方式上传 HTML/JS 等文件\n    fileUpload_multipart_html: {\n        name:   '算法3 - Multipart 方式上传 HTML/JS 等文件',\n        action: 'ignore'\n    },\n    // 文件上传 - Multipart 方式上传 DLL/EXE 等文件\n    fileUpload_multipart_exe: {\n        name:   '算法3 - Multipart 方式上传 DLL/EXE 等文件',\n        action: 'ignore'\n    },    \n\n    // OGNL 代码执行漏洞\n    ognl_exec: {\n        name:   '算法1 - 执行异常 OGNL 语句',\n        action: 'block'\n    },\n\n    // 命令执行 - java 反射、反序列化，php eval 等方式\n    command_reflect: {\n        name:   '算法1 - 通过反射执行命令，比如反序列化、加密后门',\n        action: 'block'\n    },\n    // 命令注入 - 命令执行后门，或者命令注入\n    command_userinput: {\n        name:       '算法2 - 用户输入匹配算法，包括命令注入检测',\n        action:     'block',\n        min_length: 2\n    },\n    // 命令注入 - 常见命令\n    command_common: {\n        name:    '算法3 - 识别常用渗透命令（探针）',\n        action:  'log',\n        pattern: 'cat.*/etc/passwd|nc.{1,30}-e.{1,100}/bin/(?:ba)?sh|bash\\\\s-.{0,4}i.{1,20}/dev/tcp/|subprocess.call\\\\(.{0,6}/bin/(?:ba)?sh|fsockopen\\\\(.{1,50}/bin/(?:ba)?sh|perl.{1,80}socket.{1,120}open.{1,80}exec\\\\(.{1,5}/bin/(?:ba)?sh|([\\\\|\\\\&`;\\\\x0d\\\\x0a]|$\\\\([^\\\\(]).{0,3}(ping|nslookup|curl|wget|mail).{1,10}[a-zA-Z0-9_\\\\-]{1,15}\\\\.[a-zA-Z0-9_\\\\-]{1,15}'\n    },\n    // 命令执行 - 语法错误和敏感操作\n    command_error: {\n        name:   '算法4 - 查找语法错误和敏感操作',\n        action: 'log',\n        concat_char: [\"|\", \";\"],\n        sensitive_cmd: [\"curl\", \"bash\", \"cat\", \"sh\"],\n        alarm_token: [\"$IFS\", \"${IFS}\", \"'\"]\n    },\n    // 命令执行 - 是否拦截所有命令执行？如果没有执行命令的需求，可以改为 block，最大程度的保证服务器安全\n    command_other: {\n        name:   '算法5 - 记录或者拦截所有命令执行操作',\n        action: 'ignore'\n    },\n\n    // transformer 反序列化攻击\n    deserialization_transformer: {\n        name:   '算法1 - 拦截 transformer 反序列化攻击',\n        action: 'block'\n    },\n\n    // xss 用户输入匹配算法\n    // 1. 当用户输入长度超过15，匹配上标签正则，且出现在响应里，直接拦截\n    // 2. 当用户输入长度超过15，匹配上标签正则这样的参数个数超过 10，判定为扫描攻击，直接拦截（v1.1.2 之后废弃）\n    xss_userinput: {\n        name:   '算法2 - 拦截输出在响应里的反射 XSS',\n        action: 'log',\n\n        filter_regex: \"<![\\\\-\\\\[A-Za-z]|<([A-Za-z]{1,12})[\\\/>\\\\x00-\\\\x20]\",\n        min_length:   15,\n\n        // v1.1.2 之后废弃\n        max_detection_num: 10\n    },\n\n    // php 专有算法\n    xss_echo: {\n        name:   '算法1 - PHP: 禁止直接输出 GPC 参数',\n        action: 'log',\n\n        filter_regex: \"<![\\\\-\\\\[A-Za-z]|<([A-Za-z]{1,12})[\\\/>\\\\x00-\\\\x20]\"\n    },    \n\n    webshell_eval: {\n        name:   '算法1 - 拦截简单的 PHP 中国菜刀后门',\n        action: 'block'\n    },\n\n    webshell_command: {\n        name:   '算法2 - 拦截简单的 PHP 命令执行后门',\n        action: 'block'\n    },\n\n    webshell_file_put_contents: {\n        name:   '算法3 - 拦截简单的 PHP 文件上传后门',\n        action: 'block'\n    },\n\n    webshell_callable: {\n        name:   '算法4 - 拦截简单的 PHP array_map/walk/filter 后门',\n        action: 'block',\n        functions: [\n            'system', 'exec', 'passthru', 'proc_open', 'shell_exec', 'popen', 'pcntl_exec', 'assert'\n        ]\n    },\n\n    webshell_ld_preload: {\n        name:   '算法5 - 拦截 PHP LD_PRELOAD 机制后门',\n        action: 'block'\n    },\n\n    eval_regex: {\n        name:   '算法1 - 正则表达式',\n        action: 'ignore',\n        regex:  'base64_decode|gzuncompress|create_function'\n    },\n\n    loadLibrary_unc: {\n        name:   '算法1 - 拦截 UNC 路径类库加载',\n        action: 'block'\n    },\n\n    // loadLibrary_other: {\n    //     name:   '算法2 - 记录或者拦截所有类库加载',\n    //     action: 'ignore'\n    // },\n\n    response_dataLeak: {\n        name:   '算法1 - 检查响应里是否有身份证等敏感信息（不建议开启拦截）',\n        action: 'log',\n\n        // 检查类型\n        kind: {\n            phone:         true,\n            identity_card: true,\n            bank_card:     true\n        },\n\n        // Content-Type 过滤\n        content_type: 'html|json|xml'\n    }\n}\n\n// END ALGORITHM CONFIG //\n\n// 配置挂载到全局 RASP 变量\nRASP.algorithmConfig = algorithmConfig\n\nconst clean = {\n    action:     'ignore',\n    message:    'Looks fine to me',\n    confidence: 0\n}\n\nvar forcefulBrowsing = {\n    dotFiles: /\\.(7z|tar|gz|bz2|xz|rar|zip|sql|db|sqlite)$/,\n    nonUserDirectory: /^\/(proc|sys|root)/,\n\n    // webdav 文件探针 - 最常被下载的文件\n    unwantedFilenames: [\n        // user files\n        '.DS_Store',\n        'id_rsa', 'id_rsa.pub', 'known_hosts', 'authorized_keys',\n        '.bash_history', '.csh_history', '.zsh_history', '.mysql_history',\n\n        // project files\n        '.htaccess', '.user.ini',\n\n        'web.config', 'web.xml', 'build.property.xml', 'bower.json',\n        'Gemfile', 'Gemfile.lock',\n        '.gitignore',\n        'error_log', 'error.log', 'nohup.out',\n    ],\n\n    // 目录探针 - webshell 查看频次最高的目录\n    unwantedDirectory: [\n        '/',\n        '/home',\n        '/var/log',\n        '/private/var/log',\n        '/proc',\n        '/sys',\n        'C:\\\\',\n        'D:\\\\',\n        'E:\\\\'\n    ],\n\n    // 文件探针 - webshell 查看频次最高的文件\n    absolutePaths: [\n\t    '/etc/issue',\n        '/etc/shadow',\n        '/etc/passwd',\n        '/etc/hosts',\n        '/etc/apache2/apache2.conf',\n        '/root/.bash_history',\n        '/root/.bash_profile',\n        'c:\\\\windows\\\\system32\\\\inetsrv\\\\metabase.xml',\n        'c:\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts'\n    ]\n}\n\n// 指定检测header注入时检测的header名, 统一使用小写\nvar headerInjection = [\"user-agent\", \"referer\", \"x-forwarded-for\"]\n\n// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名\nvar scriptFileRegex = /\\.(aspx?|jspx?|php[345]?|phtml|sh|py|pl|rb)\\.?$/i\n\n// 正常文件\nvar cleanFileRegex  = /\\.(jpg|jpeg|png|gif|bmp|txt|rar|zip)$/i\n\n// 匹配 HTML/JS 等可以用于钓鱼、domain-fronting 的文件\nvar htmlFileRegex   = /\\.(htm|html|js)$/i\n\n// 匹配 EXE/DLL 等可以执行的文件\nvar exeFileRegex    = /\\.(exe|dll|scr|vbs|cmd|bat)$/i\n\n// 其他的 stream 都没啥用\nvar ntfsRegex       = /::\\$(DATA|INDEX)$/\n\n// 已知用户输入匹配算法误报: 传入 1,2,3,4 -> IN(1,2,3,4)\nvar commaNumRegex   = /^[0-9, ]+$/\n\n// SQL注入算法1 - 预过滤正则\nvar sqliPrefilter1  = new RegExp(algorithmConfig.sql_userinput.pre_filter, 'i')\n\n// SQL注入算法1 - 反探测正则\nvar sqliAntiDetect = new RegExp(algorithmConfig.sql_userinput.anti_detect_filter, 'i')\n\n// SQL注入算法2 - 预过滤正则\nvar sqliPrefilter2  = new RegExp(algorithmConfig.sql_policy.pre_filter, 'i')\n\n// 命令执行探针 - 常用渗透命令\nvar cmdPostPattern  = new RegExp(algorithmConfig.command_common.pattern, 'i')\n\n// 敏感信息泄露 - Content Type 正则\nvar dataLeakContentType = new RegExp(algorithmConfig.response_dataLeak.content_type, 'i')\n\nif (! RASP.is_unittest)\n{\n   // 记录日志模式: 将所有 block 改为 log\n   if (algorithmConfig.meta.all_log)\n   {\n        Object.keys(algorithmConfig).forEach(function (name) {\n            // XXE 外部实体开关不受影响\n            if (name != 'xxe_disable_entity')\n            {\n                if (algorithmConfig[name].action == 'block') \n                {\n                    algorithmConfig[name].action = 'log'\n                }\n            }\n        })\n    }\n\n    // 研发模式: \n    // 1. 开启更多消耗性能的检测算法\n    // 2. 非攻击情况，检测到漏洞也报警\n    if (algorithmConfig.meta.is_dev) \n    {\n        // 关闭 select 预过滤正则\n        algorithmConfig.sql_userinput.pre_enable = false\n\n        // 关闭 1,2,3 误报过滤\n        commaNumRegex = /^$/\n\n        // 关闭 xss_echo 非攻击过滤\n        algorithmConfig.xss_echo.filter_regex = \"\"\n    }\n}\nelse {\n    algorithmConfig.eval_regex.action = \"log\"\n}\n\n// 校验 sql_regex 正则是否合法\nif (algorithmConfig.sql_regex.action != 'ignore') {\n    if (! algorithmConfig.sql_regex.regex.trim()) {\n        plugin.log (\"algorithmConfig.sql_regex.regex is empty, algorithm disabled\")\n        algorithmConfig.sql_regex.action = 'ignore'\n    } else {\n        try {\n            new RegExp(algorithmConfig.sql_regex)\n        } catch (e) {\n            plugin.log (\"Invalid regex in algorithmConfig.sql_regex.regex: \", e)\n            algorithmConfig.sql_regex.action = 'ignore'\n        } \n    }\n}\n\n// 校验 eval_regex 正则是否合法\nif (algorithmConfig.eval_regex.action != 'ignore') {\n    if (! algorithmConfig.eval_regex.regex.trim()) {\n        plugin.log (\"algorithmConfig.eval_regex.regex is empty, algorithm disabled\")\n        algorithmConfig.eval_regex.action = 'ignore'\n    } else {\n        try {\n            new RegExp(algorithmConfig.eval_regex)\n        } catch (e) {\n            plugin.log (\"Invalid regex in algorithmConfig.eval_regex.regex: \", e)\n            algorithmConfig.eval_regex.action = 'ignore'\n        } \n    }\n}\n\n\n// 常用函数\nString.prototype.replaceAll = function(token, tokenValue, maxLength) {\n    if (maxLength === undefined) {\n        maxLength = 4096\n    }\n    // 空值判断，防止死循环\n    if (! token || token.length == 0 || this.length > maxLength) {\n        return this\n    }\n\n    var index  = 0;\n    var string = this;\n\n    do {\n        string = string.replace(token, tokenValue);\n    } while((index = string.indexOf(token, index)) > -1);\n\n    return string\n}\n\n// function canonicalPath (path) {\n//     return path.replaceAll('/./', '/').replaceAll('//', '/').replaceAll('//', '/')\n// }\n\n// 我们不再需要简化路径，当出现两个 /../ 或者两个 \\..\\ 就可以判定为路径遍历攻击了，e.g\n// /./././././home/../../../../etc/passwd\n// \\\\..\\\\..\\\\..\n// \/..\/..\/..\nfunction has_traversal (path) {\n\n    // 左右斜杠，一视同仁\n    var path2 = \"/\" + path.replaceAll('\\\\', '/') + \"/\"\n    // 覆盖 ../../\n    // 以及 /../../\n    var left  = path2.indexOf('/../')\n    var right = path2.lastIndexOf('/../')\n\n    if (left != -1 && right != -1 && left != right)\n    {\n        return true\n    }\n\n    return false\n}\n\n// 判断参数是否包含路径穿越，比path更严格\nfunction param_has_traversal (param) {\n    // 左右斜杠，一视同仁\n    var path = \"/\" + param.replaceAll('\\\\', '/') + \"/\"\n\n    if (path.indexOf(\"/../\") != -1)\n    {\n        return true\n    }\n    return false\n}\n\nfunction is_hostname_dnslog(hostname) {\n    var domains = algorithmConfig.ssrf_common.domains\n\n    if (hostname == 'requestb.in' || hostname == 'transfer.sh')\n    {\n        return true\n    }\n\n    for (var i = 0; i < domains.length; i ++)\n    {\n        if (hostname.endsWith(domains[i]))\n        {\n            return true\n        }\n    }\n\n    return false\n}\n\n// function basename (path) {\n//     // 简单处理，同时支持 windows/linux\n//     var path2 = path.replaceAll('\\\\', '/')\n//     var idx   = path2.lastIndexOf('/')\n//     return path.substr(idx + 1)\n// }\n\n// function has_file_extension(path) {\n//     var filename = basename(path)\n//     var index    = filename.indexOf('.')\n\n//     if (index > 0 && index != filename.length - 1) {\n//         return true\n//     }\n\n//     return false\n// }\n\nfunction validate_stack_php(stacks) {\n    var verdict = false\n\n    for (var i = 0; i < stacks.length; i ++) {\n        var stack = stacks[i]\n\n        // 来自 eval/assert/create_function/...\n        if (stack.indexOf('eval()\\'d code') != -1\n            || stack.indexOf('runtime-created function') != -1\n            || stack.indexOf('assert code@') != -1\n            || stack.indexOf('regexp code@') != -1) {\n            verdict = true\n            break\n        }\n\n        // call_user_func/call_user_func_array 两个函数调用很频繁\n        // 必须是 call_user_func 直接调用 system/exec 等函数才拦截，否则会有很多误报\n        if (stack.indexOf('@call_user_func') != -1) {\n            if (i <= 1) {\n                verdict = true\n                break\n            }\n        }\n    }\n\n    return verdict\n}\n\nfunction is_absolute_path(path, is_windows) {\n\n    // Windows - C:\\\\windows\n    if (is_windows) {\n\n        if (path[1] == ':')\n        {\n            var drive = path[0].toLowerCase()\n            if (drive >= 'a' && drive <= 'z')\n            {\n                return true\n            }\n        }\n    }\n\n    // Unices - /root/\n    return path[0] === '/'\n}\n\nfunction is_outside_webroot(appBasePath, realpath, path) {\n    var verdict = false\n\n    // 如果指定path 为 null 则不校验目录穿越\n    if (path == null || has_traversal(path)) {\n        // servlet 3.X 之后可能会获取不到 appBasePath，或者为空\n        // 提前加个判断，防止因为bug导致误报\n        if (! appBasePath || appBasePath.length == 0) {\n            verdict = false\n        }\n        else if (realpath.indexOf(appBasePath) == -1) {\n            verdict = true\n        }\n    }\n\n    return verdict\n}\n\n// 路径是否来自用户输入\n// file_get_contents(\"/etc/passwd\");\n// file_get_contents(\"../../../../../../../etc/passwd\");\n//\n// 或者以用户输入结尾\n// file_get_contents(\"/data/uploads/\" . \"../../../../../../../etc/passwd\");\nfunction is_path_endswith_userinput(parameter, target, realpath, is_windows, is_lcs_search)\n{\n    var verdict = false\n\n    Object.keys(parameter).some(function (key) {\n        // 只处理非数组、hash情况\n        Object.values(parameter[key]).some(function (value){\n            // 只处理字符串类型的\n            if (typeof value != 'string') {\n                return\n            }\n            // 如果应用做了特殊处理， 比如传入 file:///etc/passwd，实际看到的是 /etc/passwd\n            if (value.startsWith('file://') && \n                is_absolute_path(target, is_windows) && \n                value.endsWith(target)) \n            {\n                verdict = true\n                return true\n            }\n\n            // 去除多余/ 和 \\ 的路径\n            var simplifiedValue\n            var simplifiedTarget\n\n            // Windows 下面\n            // 传入 ../../../conf/tomcat-users.xml\n            // 看到 c:\\tomcat\\webapps\\root\\..\\..\\conf\\tomcat-users.xml\n            if (is_windows) {\n                value = value.replaceAll('/', '\\\\')\n                target = target.replaceAll('/', '\\\\')\n                realpath = realpath.replaceAll('/', '\\\\')\n                simplifiedTarget = target.replaceAll('\\\\\\\\','\\\\')\n                simplifiedValue = value.replaceAll('\\\\\\\\','\\\\')\n            } else{\n                simplifiedTarget = target.replaceAll('//','/')\n                simplifiedValue = value.replaceAll('//','/')\n            }\n            var simplifiedValues\n            if ( is_lcs_search ) {\n                simplifiedValues = lcs_search( simplifiedValue, simplifiedTarget )\n            }\n            else {\n                simplifiedValues = [simplifiedValue]\n            }\n            for(var i = 0, len = simplifiedValues.length; i < len; i++) {\n                simplifiedValue = simplifiedValues[i]\n                // 参数必须有跳出目录，或者是绝对路径\n                if ((target.endsWith(value) || simplifiedTarget.endsWith(simplifiedValue))\n                    && (param_has_traversal(value) || value == realpath || simplifiedValue == realpath))\n                {\n                    verdict = true\n                    return true\n                }\n            }\n        })\n        if (verdict){\n            return true\n        }\n    })\n    return verdict\n}\n\n// 检查是否包含用户输入 - 适合目录\nfunction is_path_containing_userinput(parameter, target, is_windows, is_lcs_search)\n{\n    var verdict = false\n    if (is_windows) {\n        target = target.replaceAll('/', '\\\\')\n        target = target.replaceAll('\\\\\\\\', '\\\\')\n    }\n    else{\n        target = target.replaceAll('//', '/')\n    }\n\n    Object.keys(parameter).some(function (key) {\n        var values = parameter[key]\n        Object.values(values).some(function(value){\n            // 只处理字符串类型的\n            if (typeof value != 'string') {\n                return\n            }\n            if (is_windows) {\n                value = value.replaceAll('/', '\\\\')\n                value = value.replaceAll('\\\\\\\\', '\\\\')\n            }\n            else {\n                value = value.replaceAll('//', '/')\n            }\n            var values\n            if (is_lcs_search) {\n                values = lcs_search(value, target)\n            }\n            else {\n                // java 下面，传入 /usr/ 会变成 /usr，所以少匹配一个字符\n                if ( value.charAt(value.length - 1) == \"/\" || \n                    value.charAt(value.length - 1) == \"\\\\\" ) {\n                    value = value.substr(0, value.length - 1)\n                }\n                values = [value]\n            }\n            for(var i = 0, len = values.length; i < len; i++) {\n                // 只处理非数组、hash情况\n                if (param_has_traversal(values[i]) && target.indexOf(values[i]) != -1) {\n                    verdict = true\n                    return true\n                }\n            }\n        })\n        if (verdict){\n            return true\n        }\n    })\n    return verdict\n}\n\n// 是否来自用户输入 - 适合任意类型参数\nfunction is_from_userinput(parameter, target)\n{\n    var verdict = false\n    Object.keys(parameter).some(function (key) {\n        var values = parameter[key]\n        Object.values(values).some(function(value){\n            // 只处理非数组、hash情况\n            if (value == target) {\n                verdict = true\n                return true\n            }\n        })\n    })\n    return verdict\n}\n\n// 检查逻辑是否被用户参数所修改\nfunction is_token_changed(raw_tokens, userinput_idx, userinput_length, distance, is_sql)\n{\n    if (is_sql === undefined) {\n        is_sql = false\n    }\n    // 当用户输入穿越了多个token，就可以判定为代码注入，默认为2\n    var start = -1, end = raw_tokens.length, distance = distance || 2\n\n    // 寻找 token 起始点，可以改为二分查找\n    for (var i = 0; i < raw_tokens.length; i++)\n    {\n        if (raw_tokens[i].stop > userinput_idx)\n        {\n            start = i\n            break\n        }\n    }\n\n    // 寻找 token 结束点\n    // 需要返回真实distance, 删除 最多需要遍历 distance 个 token  i < start + distance 条件\n    for (var i = start; i < raw_tokens.length; i++)\n    {\n        if (raw_tokens[i].stop >= userinput_idx + userinput_length)\n        {\n            end = i\n            break\n        }\n    }\n\n    var diff = end - start + 1\n    if (diff >= distance) {\n        if (is_sql && algorithmConfig.sql_userinput.anti_detect_enable && diff < 10) {\n            var non_kw = 0\n            for (var i = start; i <= end; i++) {\n                sqliAntiDetect.test(raw_tokens[i].text) || non_kw ++\n                if (non_kw >= 2) {\n                    return true\n                }\n            }\n            return false\n        }\n        return true\n    }\n    return false\n}\n\n// 查找str1和str2的最长公共子串，返回为所有最长子串组成的数组\nfunction lcs_search(str1, str2){\n    var len1 = str1.length;\n    var len2 = str2.length;\n    var dp_arr = [[],[]]\n    var pre = 1\n    var now = 0\n    var result =0\n    var result_pos = []\n\n    for (var i = 0; i <= len2+1; i ++) {\n        dp_arr[0][i] = 0\n        dp_arr[1][i] = 0\n    }\n    for (var i = 0; i <= len1; i ++) {\n        for (var j = 0; j <= len2; j ++) {\n            if ( i == 0 || j == 0 ){\n                dp_arr[now][j] = 0\n            }\n            else if ( str1[i-1] == str2[j-1] ) {\n                dp_arr[now][j] = dp_arr[pre][j-1] + 1\n                if (dp_arr[now][j] > result){\n                    result = dp_arr[now][j]\n                    result_pos = [i - result]\n                }else if (dp_arr[now][j] == result){\n                    result_pos.push( i - result )\n                }\n            }\n            else {\n                dp_arr[now][j] = 0\n            }\n        }\n        if( now == 0 ){\n            now = 1\n            pre = 0\n        }\n        else {\n            now = 0\n            pre = 1\n        }\n    }\n    var result_pos_set = new Set(result_pos)\n    var result_str = new Set()\n    for (var item of result_pos_set) {\n        result_str.add(str1.substr(item, result))\n    }\n    return Array.from(result_str)\n}\n\n// 从字符串中解析cookie\nfunction get_cookies(cookie_str) {\n    cookie_items = cookie_str.split(';')\n    var result = {}\n    for(i = 0; i < cookie_items.length; i++) {\n        item = cookie_items[i].trim()\n        if (item.length == 0) {\n            continue\n        }\n        else {\n            key_len = item.indexOf(\"=\")\n            if (key_len <= 0) {\n                continue\n            }\n            key = unescape(item.substr(0, key_len))\n            value = unescape(item.substr(key_len + 1))\n            result[key] = value\n        }\n    }\n    return result\n}\n\n// 合并context.parameter中 header、cookie、parameter、json参数， header、cookie的key会被重命名\nfunction get_all_parameter(context) {\n    if (context.get_all_parameter !== undefined) {\n        return context.parameter || {}\n    }\n    context.get_all_parameter = true\n    var key_num = 0\n    var parameter = context.parameter || {}\n    if ( context.header != null) {\n        for (name in context.header) {\n            if ( name.toLowerCase() == \"cookie\") {\n                var cookies = get_cookies(context.header.cookie)\n                for (name in cookies) {\n                    while(\"cookie\" + key_num + \"_\" + name in parameter) {\n                        key_num ++\n                    }\n                    parameter[\"cookie\" + key_num + \"_\" + name] = [cookies[name]]\n                }\n            }\n            else if ( headerInjection.indexOf(name.toLowerCase()) != -1) {\n                while(\"header\" + key_num + \"_\" + name in parameter) {\n                    key_num ++\n                }\n                parameter[\"header\" + key_num + \"_\" + name] = [context.header[name]]\n            }\n        }\n        var jsons = [ [context.json || {}, \"input_json\"] ]\n        while (jsons.length > 0) {\n            var json_arr = jsons.pop()\n            var crt_json_key = json_arr[1]\n            var json_obj = json_arr[0]\n            for (item in json_obj) {\n                if (typeof json_obj[item] == \"string\") {\n                    while(\"json\" + key_num + \"_\" + crt_json_key + \"->\" + item in parameter) {\n                        key_num ++\n                    }\n                    parameter[\"json\" + key_num + \"_\" + crt_json_key + \"->\" + item] = [json_obj[item]]\n                }\n                else if (typeof json_obj[item] == \"object\") {\n                    jsons.push([json_obj[item], crt_json_key + \"->\" + item])\n                }\n            }\n        }\n    }\n    return parameter\n}\n\nfunction check_ssrf(params, context, is_redirect) {\n    var hostname  = params.hostname\n    var url       = params.url\n    var ip        = params.ip\n    var reason    = false\n\n    // 算法1 - 当参数来自用户输入，且为内网IP，判定为SSRF攻击\n    if (algorithmConfig.ssrf_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n        if (is_redirect || is_from_userinput(all_parameter, url))\n        {\n            for (var i=0; i<ip.length; i++) {\n                if (/^(127|10|192\\.168|172\\.(1[6-9]|2[0-9]|3[01]))\\./.test(ip[i]))\n                {\n                    if (!(is_redirect && /^(127|10|192\\.168|172\\.(1[6-9]|2[0-9]|3[01]))\\./.test(params.origin_ip))){\n                        return {\n                            action:     algorithmConfig.ssrf_userinput.action,\n                            message:    _(\"SSRF - Requesting intranet address: %1%\", [ ip[i] ]),\n                            confidence: 100,\n                            algorithm:  'ssrf_userinput'\n                        }\n                    }\n                }\n            }\n            \n            if (hostname == '[::]' || hostname == '::1' || hostname == '0.0.0.0') \n            {\n                return {\n                    action:     algorithmConfig.ssrf_userinput.action,\n                    message:    _(\"SSRF - Requesting intranet address: %1%\", [ hostname ]),\n                    confidence: 100,\n                    algorithm:  'ssrf_userinput'\n                }\n            }\n        }\n    }\n\n    // 算法2 - 检查常见探测域名\n    if (algorithmConfig.ssrf_common.action != 'ignore')\n    {\n        if (is_hostname_dnslog(hostname))\n        {\n            return {\n                action:     algorithmConfig.ssrf_common.action,\n                message:    _(\"SSRF - Requesting known DNSLOG address: %1%\", [hostname]),\n                confidence: 100,\n                algorithm:  'ssrf_common'\n            }\n        }\n    }\n\n    // 算法3 - 检测 AWS/Aliyun/GoogleCloud 私有地址: 拦截IP访问、绑定域名访问两种方式\n    if (algorithmConfig.ssrf_aws.action != 'ignore')\n    {\n        if (ip == '169.254.169.254' || ip == '100.100.100.200'\n            || hostname == '169.254.169.254' || hostname == '100.100.100.200' || hostname == 'metadata.google.internal')\n        {\n            return {\n                action:     algorithmConfig.ssrf_aws.action,\n                message:    _(\"SSRF - Requesting AWS metadata address\"),\n                confidence: 100,\n                algorithm:  'ssrf_aws'\n            }\n        }\n    }\n\n    // 算法4 - ssrf_obfuscate\n    //\n    // 检查混淆:\n    // http://2130706433\n    // http://0x7f001\n    //\n    // 以下混淆方式没有检测，容易误报\n    // http://0x7f.0x0.0x0.0x1\n    // http://0x7f.0.0.0\n    if (algorithmConfig.ssrf_obfuscate.action != 'ignore')\n    {\n        var reason = false\n\n        if (!isNaN(hostname) && hostname.length != 0)\n        {\n            reason = _(\"SSRF - Requesting numeric IP address: %1%\", [hostname])\n        }\n        // else if (hostname.startsWith('0x') && hostname.indexOf('.') === -1)\n        // {\n        //     reason = _(\"SSRF - Requesting hexadecimal IP address: %1%\", [hostname])\n        // }\n\n        if (reason)\n        {\n            return {\n                action:     algorithmConfig.ssrf_obfuscate.action,\n                message:    reason,\n                confidence: 100,\n                algorithm:  'ssrf_obfuscate'\n            }\n        }\n    }\n\n    // 算法5 - 特殊协议检查\n    if (algorithmConfig.ssrf_protocol.action != 'ignore')\n    {\n        // 获取协议\n        var proto = url.split(':')[0].toLowerCase()\n\n        if (algorithmConfig.ssrf_protocol.protocols.indexOf(proto) != -1)\n        {\n            return {\n                action:     algorithmConfig.ssrf_protocol.action,\n                message:    _(\"SSRF - Using dangerous protocol: %1%://\", [proto]),\n                confidence: 100,\n                algorithm:  'ssrf_protocol'\n            }\n        }\n    }\n    return false\n}\n\n// 下个版本将会支持翻译，目前还需要暴露一个 getText 接口给插件\nfunction _(message, args) \n{\n    args = args || []\n\n    for (var i = 0; i < args.length; i ++) \n    {\n        var symbol = '%' + (i + 1) + '%'\n        message = message.replace(symbol, args[i])\n    }\n\n    return message\n}\n\n// 开始\n\n// 若开启「研发模式」，将只使用JS插件\nif (! algorithmConfig.meta.is_dev && RASP.get_jsengine() !== 'v8') {\n    // v1.1 之前的版本，SQL/SSRF 使用 java 原生实现，需要将插件配置传递给 java\n    // v1.0 RC1 之前仍然需要使用 RASP.config_set 传递配置\n    if (RASP.config_set) {\n        RASP.config_set('algorithm.config', JSON.stringify(algorithmConfig))\n    }\n    // 用于 v1.0 rhino \n    Object.values = function (obj){\n        var result = Array()\n        for (key in obj) {\n            result.push(obj[key])\n        }\n        return result\n    }\n} else {\n    // 对于PHP + V8，性能还不错，我们保留JS检测逻辑\n    plugin.register('sql', function (params, context) {\n\n        var reason          = false\n        var min_length      = algorithmConfig.sql_userinput.min_length\n        var allow_full      = algorithmConfig.sql_userinput.allow_full\n        var parameters      = context.parameter || {}\n        var json_parameters = context.json || {}\n        var raw_tokens      = []\n\n        function _run(values, name) {\n            var reason = false\n            values.some(function (value) {\n                // 不处理3维及以上的数组\n                if (typeof value != \"string\") {\n                    return false\n                }\n\n                // 最短长度限制\n                if (value.length < min_length) {\n                    return false\n                }\n\n                // 使用lcs查找或直接查找\n                if (algorithmConfig.sql_userinput.lcs_search) {\n                    check_value = lcs_search(params.query, value)\n                }\n                else{\n                    check_value = [value]\n                }\n\n                // 检查用户输入是否存在于SQL中\n                for(var i = 0, len = check_value.length; i < len; i++) {\n                    value = check_value[i]\n                \n                    var userinput_idx = params.query.indexOf(value)\n                    if (userinput_idx == -1) {\n                        return false\n                    }\n\n                    // 如果允许数据库管理器\n                    if (allow_full && params.query.length == value.length)\n                    {\n                        return false\n                    }\n\n                    // 过滤已知误报\n                    // 1,2,3,4,5 -> IN(1,2,3,4,5)\n                    if (commaNumRegex.test(value)) {\n                        return false\n                    }\n\n                    // 预过滤正则，如果开启\n                    if (algorithmConfig.sql_userinput.pre_enable && ! sqliPrefilter1.test(value)) {\n                        return false\n                    }\n\n                    // 懒加载，需要的时候初始化 token\n                    if (raw_tokens.length == 0) {\n                        raw_tokens = RASP.sql_tokenize(params.query, params.server)\n                    }\n\n                    //distance用来屏蔽identifier token解析误报 `dbname`.`table`，请在1.2版本后删除\n                    var distance = 2\n                    if (value.length > 20) {\n                        distance = 3\n                    }\n                    if (is_token_changed(raw_tokens, userinput_idx, value.length, distance, is_sql=true)) {\n                        reason = _(\"SQLi - SQL query structure altered by user input, request parameter name: %1%, value: %2%\", [name, value])\n                        return true\n                    }\n                }\n            })\n            return reason\n        }\n\n        // 算法1: 匹配用户输入，简单识别逻辑是否发生改变\n        if (algorithmConfig.sql_userinput.action != 'ignore') {\n\n            // 匹配 GET/POST/multipart 参数\n            Object.keys(parameters).some(function (name) {\n                // 覆盖场景，后者仅PHP支持\n                // ?id=XXXX\n                // ?data[key1][key2]=XXX\n                var value_list = []\n                Object.values(parameters[name]).forEach(function (value){\n                    if (typeof value == 'string') {\n                        value_list.push(value)\n                    } else {\n                        value_list = value_list.concat(Object.values(value))\n                    }\n                })\n                reason = _run(value_list, name)\n                if (reason) {\n                    return true\n                }\n            })\n\n            // 匹配 header 参数\n            if (reason == false && context.header != null) {\n                Object.keys(context.header).some(function (name) {\n                    if ( name.toLowerCase() == \"cookie\") {\n                        var cookies = get_cookies(context.header.cookie)\n                        for (name in cookies) {\n                            reason = _run([cookies[name]], \"cookie:\" + name)\n                            if (reason) {\n                                return true\n                            }\n                        }\n                    }\n                    else if ( headerInjection.indexOf(name.toLowerCase()) != -1) {\n                        reason = _run([context.header[name]], \"header:\" + name)\n                        if (reason) {\n                            return true\n                        }\n                    }\n                    \n                })\n            }\n\n            // 匹配json参数\n            if (reason == false && Object.keys(json_parameters).length > 0) {\n                var jsons = [ [json_parameters, \"input_json\"] ]\n                while (jsons.length > 0 && reason === false) {\n                    var json_arr = jsons.pop()\n                    var crt_json_key = json_arr[1]\n                    var json_obj = json_arr[0]\n                    for (item in json_obj) {\n                        if (typeof json_obj[item] == \"string\") {\n                            reason = _run([json_obj[item]], crt_json_key + \"->\" + item)\n                            if(reason !== false) {\n                                break;\n                            }\n                        }\n                        else if (typeof json_obj[item] == \"object\") {\n                            jsons.push([json_obj[item], crt_json_key + \"->\" + item])\n                        }\n                    }\n                }\n            }\n\n            if (reason !== false) {\n                return {\n                    action:     algorithmConfig.sql_userinput.action,\n                    confidence: 90,\n                    message:    reason,\n                    algorithm:  'sql_userinput'\n                }\n            }\n        }\n\n        // 算法2: SQL语句策略检查（模拟SQL防火墙功能）\n        if (algorithmConfig.sql_policy.action != 'ignore') {\n\n            // 懒加载，需要时才处理\n            if ((raw_tokens.length == 0) && \n                (sqliPrefilter2.test(params.query))) {\n                raw_tokens = RASP.sql_tokenize(params.query, params.server)\n            }\n\n            var features        = algorithmConfig.sql_policy.feature\n            var func_list       = algorithmConfig.sql_policy.function_blacklist\n            var func_count_list = algorithmConfig.sql_policy.function_count\n\n            // 黑名单函数计数\n            var func_count_arr  = {}\n\n            // 转换小写，避免大小写绕过\n            var tokens_lc = raw_tokens.map(function(v) {\n                return v.text.substr(0, 50).toLowerCase()\n            })\n\n            for (var i = 1; i < tokens_lc.length; i ++)\n            {\n                if (features['union_null'] && tokens_lc[i] === 'select')\n                {\n                    var null_count = 0\n\n                    // 寻找连续的逗号、NULL或者数字\n                    for (var j = i + 1; j < tokens_lc.length && j < i + 6; j ++) {\n                        if (tokens_lc[j] === ',' || tokens_lc[j] == 'null' || ! isNaN(parseInt(tokens_lc[j]))) {\n                            null_count ++\n                        } else {\n                            break\n                        }\n                    }\n\n                    // NULL,NULL,NULL == 5个token\n                    // 1,2,3          == 5个token\n                    if (null_count >= 5) {\n                        reason = _(\"SQLi - Detected UNION-NULL phrase in sql query\")\n                        break\n                    }\n                    continue\n                }\n\n                if (features['stacked_query'] && tokens_lc[i] == ';' && i != tokens_lc.length - 1)\n                {\n                    reason = _(\"SQLi - Detected stacked queries\")\n                    break\n                }\n                else if (features['no_hex'] && tokens_lc[i][0] === '0' && tokens_lc[i][1] === 'x')\n                {\n                    reason = _(\"SQLi - Detected hexadecimal values in sql query\")\n                    break\n                }\n                else if (features['version_comment'] && tokens_lc[i][0] === '/' && tokens_lc[i][1] === '*' && tokens_lc[i][2] === '!')\n                {\n                    reason = _(\"SQLi - Detected MySQL version comment in sql query\")\n                    break\n                }\n                else if (features['function_blacklist'] && i > 0 && tokens_lc[i][0] === '(')\n                {\n                    var func_name = tokens_lc[i - 1]\n                    if (func_list[func_name])\n                    {\n                        reason = _(\"SQLi - Detected dangerous method call %1%() in sql query\", [func_name])\n                        break\n                    }\n\n                    if (features['function_count'] && func_count_list[func_name])\n                    {\n                        if (! func_count_arr[func_name])\n                        {\n                            func_count_arr[func_name] = 1\n                        }\n                        else\n                        {\n                            func_count_arr[func_name] ++\n                        }\n\n                        // 超过次数拦截\n                        if (func_count_arr[func_name] >= func_count_list[func_name]) \n                        {\n                            reason = _(\"SQLi - Detected multiple call to dangerous method %1%() in sql query (%2% times)\", [func_name, func_count_arr[func_name]])\n                            break\n                        }\n                    }\n                }            \n                else if (features['into_outfile'] && i < tokens_lc.length - 2 && tokens_lc[i] == 'into')\n                {\n                    if (tokens_lc[i + 1] == 'outfile' || tokens_lc[i + 1] == 'dumpfile')\n                    {\n                        reason = _(\"SQLi - Detected INTO OUTFILE phrase in sql query\")\n                        break\n                    }\n                }\n                else if (features['information_schema'] && i < tokens_lc.length - 1 && tokens_lc[i] == 'from')\n                {\n                    // `information_schema`.tables\n                    // information_schema  .tables\n                    var part = tokens_lc[i + 1].replaceAll('`', '', 40)\n                    // 正常的antlr和flex返回1个token\n                    if (part == 'information_schema.tables')\n                    {\n                        reason = _(\"SQLi - Detected access to MySQL information_schema.tables table\")\n                        break\n                    }\n                    // flex在1.1.2以前会产生3个token\n                    else if (part == 'information_schema' && i < tokens_lc.length - 3)\n                    {\n                        var part2 = tokens_lc[i + 3].replaceAll('`', '', 10)\n                        if (part2 == \"tables\")\n                        {\n                            reason = _(\"SQLi - Detected access to MySQL information_schema.tables table\")\n                            break\n                        }\n                    }\n                }\n            }\n\n            if (reason !== false) \n            {\n                return {\n                    action:     algorithmConfig.sql_policy.action,\n                    message:    reason,\n                    confidence: 100,\n                    algorithm:  'sql_policy'\n                }\n            }\n        }\n\n        // 算法4: SQL正则表达式\n        if (algorithmConfig.sql_regex.action != 'ignore') {\n            var regex_filter = new RegExp(algorithmConfig.sql_regex.regex, 'i')\n            \n            if (regex_filter.test(params.query)) {\n                return {\n                    action:     algorithmConfig.sql_regex.action,\n                    confidence: 60,\n                    message:    reason,\n                    algorithm:  'sql_regex'\n                }\n            }\n        }\n\n        // 加入缓存，对 prepared sql 特别有效\n        return clean\n    })\n\n    plugin.register('ssrf', function(params, context) {\n        var ret = check_ssrf(params, context, false)\n        if (ret !== false) {\n            return ret\n        }\n        return clean\n    })\n\n    plugin.register('ssrfRedirect', function(params, context) {\n        var params2 = {\n            // 使用原始url，用于检测用户输入\n            url: params.url2,\n            hostname: params.hostname2,\n            ip: params.ip2,\n            ip_origin: params.ip,\n            port: params.port2,\n            function: params.function\n        }\n        var ret2 = check_ssrf(params2, context, true)\n        if (ret2 !== false) {\n            ret = check_ssrf(params, context, false)\n            if (ret === false) {\n                return ret2\n            }\n        }\n        return clean\n    })\n}\n\nplugin.register('sql_exception', function(params, context) {\n    // 为了提高效率，异常代码在 agent 端过滤，插件仅负责过滤掉可能的误报和拼接消息，e.g\n    // mysql error 1367 detected: XXX\n    var error_code = parseInt(params.error_code)\n    var message    = _(\"%1% error %2% detected: %3%\", [params.server, params.error_code, params.error_msg])\n\n    // 1062 Duplicated key 错误会有大量误报问题，仅当语句里包含 rand 字样报警\n    if (error_code == 1062) {\n        // 忽略大小写匹配\n        if ( !/rand/i.test(params.query)) {\n            return clean\n        }\n    }\n\n    else if (error_code == 1064) {\n        if ( /in\\s*\\(\\s*\\)/i.test(params.query)) {\n            return clean\n        }\n    }\n    \n    return {\n        action:     algorithmConfig.sql_exception.action,\n        message:    message,\n        confidence: 70,\n        algorithm:  'sql_exception'\n    }\n})\n\nplugin.register('directory', function (params, context) {\n\n    var realpath    = params.realpath\n    var server      = context.server\n\n    var is_windows  = server.os.indexOf('Windows') != -1\n    var language    = server.language\n\n    // 算法2 - 检查PHP菜刀等后门\n    if (algorithmConfig.directory_reflect.action != 'ignore')\n    {\n        // 目前，只有 PHP 支持通过堆栈方式，拦截列目录功能\n        if (language == 'php' && validate_stack_php(params.stack))\n        {\n            return {\n                action:     algorithmConfig.directory_reflect.action,\n                message:    _(\"WebShell activity - Using file manager function with China Chopper WebShell\"),\n                confidence: 90,\n                algorithm:  'directory_reflect'\n            }\n        }\n    }\n\n    // 算法1 - 用户输入匹配。\n    if (algorithmConfig.directory_userinput.action != 'ignore')\n    {\n       var all_parameter = get_all_parameter(context)\n\n        if (is_path_containing_userinput(all_parameter, params.path, is_windows, algorithmConfig.directory_userinput.lcs_search))\n        {\n            return {\n                action:     algorithmConfig.directory_userinput.action,\n                message:    _(\"Path traversal - Accessing folder specified by userinput, folder is %1%\", [realpath]),\n                confidence: 90,\n                algorithm:  'directory_userinput'\n            }\n        }\n    }\n\n    // 算法3 - 读取敏感目录\n    if (algorithmConfig.directory_unwanted.action != 'ignore')\n    {\n        for (var i = 0; i < forcefulBrowsing.unwantedDirectory.length; i ++) {\n            if (realpath == forcefulBrowsing.unwantedDirectory[i]) {\n                return {\n                    action:     algorithmConfig.directory_unwanted.action,\n                    message:    _(\"WebShell activity - Accessing sensitive folder: %1%\", [realpath]),\n                    confidence: 100,\n                    algorithm:  'directory_unwanted'\n                }\n            }\n        }\n    }\n\n    return clean\n})\n\n\nplugin.register('readFile', function (params, context) {\n    var server    = context.server\n    var is_win    = server.os.indexOf('Windows') != -1\n\n    // weblogic/tongweb 下面，所有war包读取操作全部忽略\n    if (server['server'] === 'weblogic' || server['server'] == 'tongweb')\n    {\n        if (params.realpath.endsWith('.war'))\n        {\n            return clean;\n        }\n    }\n\n    //\n    // 算法1: 简单用户输入识别，拦截任意文件下载漏洞\n    //\n    // 不影响正常操作，e.g\n    // ?path=download/1.jpg\n    //\n    if (algorithmConfig.readFile_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n\n        // ?path=/etc/./hosts\n        // ?path=../../../etc/passwd\n        if (is_path_endswith_userinput(all_parameter, params.path, params.realpath, is_win, algorithmConfig.readFile_userinput.lcs_search))\n        {\n            return {\n                action:     algorithmConfig.readFile_userinput.action,\n                message:    _(\"Path traversal - Downloading files specified by userinput, file is %1%\", [params.realpath]),\n                confidence: 90,\n                algorithm: 'readFile_userinput'\n            }\n        }\n        // @FIXME: 用户输入匹配了两次，需要提高效率\n        if (is_from_userinput(all_parameter, params.path))\n        {\n            // 获取协议，如果有\n            var proto = params.path.split('://')[0].toLowerCase()\n            // 1. 读取 http(s):// 内容\n            // ?file=http://www.baidu.com\n            if (proto === 'http' || proto === 'https')\n            {\n                if (algorithmConfig.readFile_userinput_http.action != 'ignore')\n                {\n                    return {\n                        action:     algorithmConfig.readFile_userinput_http.action,\n                        message:    _(\"SSRF - Requesting http/https resource with file streaming functions, URL is %1%\", [params.path]),\n                        confidence: 90,\n                        algorithm:  'readFile_userinput_http'\n                    }\n                }\n            }\n\n            // 2. 读取特殊协议内容\n            // ?file=file:///etc/passwd\n            // ?file=php://filter/read=convert.base64-encode/resource=XXX\n            if (proto === 'file' || proto === 'php')\n            {\n                if (algorithmConfig.readFile_userinput_unwanted.action != 'ignore')\n                {\n                    return {\n                        action:     algorithmConfig.readFile_userinput_unwanted.action,\n                        message:    _(\"Path traversal - Requesting unwanted protocol %1%://\", [proto]),\n                        confidence: 90,\n                        algorithm:  'readFile_userinput_unwanted'\n                    }\n                }\n            }\n        }\n    }\n\n    //\n    // 算法2: 文件、目录探针\n    // 如果应用读取了列表里的文件，比如 /root/.bash_history，这通常意味着后门操作\n    //\n    if (algorithmConfig.readFile_unwanted.action != 'ignore')\n    {\n        var realpath_lc = params.realpath.toLowerCase()\n        for (var j = 0; j < forcefulBrowsing.absolutePaths.length; j ++) {\n            if (forcefulBrowsing.absolutePaths[j] == realpath_lc) {\n                return {\n                    action:     algorithmConfig.readFile_unwanted.action,\n                    message:    _(\"WebShell activity - Accessing sensitive file %1%\", [params.realpath]),\n                    confidence: 90,\n                    algorithm:  'readFile_unwanted'\n                }\n            }\n        }\n    }\n\n    //\n    // 算法3: 检查文件遍历，看是否超出web目录范围 [容易误报~]\n    //\n    if (algorithmConfig.readFile_outsideWebroot.action != 'ignore')\n    {\n        var path        = params.path\n        var appBasePath = context.appBasePath\n\n        if (is_outside_webroot(appBasePath, params.realpath, path)) {\n            return {\n                action:     algorithmConfig.readFile_outsideWebroot.action,\n                message:    _(\"Path traversal - accessing files outside webroot (%1%), file is %2%\", [appBasePath, params.realpath]),\n                confidence: 90,\n                algorithm:  'readFile_outsideWebroot'\n            }\n        }\n    }\n\n\n    return clean\n})\n\nplugin.register('include', function (params, context) {\n    var url       = params.url\n    var server    = context.server\n    var is_win    = server.os.indexOf('Windows') != -1\n    var realpath  = params.realpath\n\n    // 用户输入检查\n    // ?file=/etc/passwd\n    // ?file=../../../../../var/log/httpd/error.log\n    if (algorithmConfig.include_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n\n        if (is_path_endswith_userinput(all_parameter, url, realpath, is_win, algorithmConfig.include_userinput.lcs_search))\n        {\n            return {\n                action:     algorithmConfig.include_userinput.action,\n                message:    _(\"File inclusion - including files specified by user input\"),\n                confidence: 100,\n                algorithm:  'include_userinput'\n            }\n        }\n    }\n\n    // 如果有协议\n    // include ('http://xxxxx')\n    var items = url.split('://')\n    var proto = items[0].toLowerCase()\n\n    // 特殊协议，\n    // include('file://XXX')\n    // include('php://XXX')\n    if (algorithmConfig.include_protocol.action != 'ignore')\n    {\n        if (algorithmConfig.include_protocol.protocols.indexOf(proto) != -1)\n        {\n            return {\n                action:     algorithmConfig.include_protocol.action,\n                message:    _(\"File inclusion - using unwanted protocol '%1%://' with funtion %2%()\", [proto, params.function]),\n                confidence: 90,\n                algorithm:  'include_protocol'\n            }\n        }\n    }\n\n    return clean\n})\n\nplugin.register('writeFile', function (params, context) {\n\n    // 写 NTFS 流文件，通常是为了绕过限制\n    if (algorithmConfig.writeFile_NTFS.action != 'ignore')\n    {\n        if (ntfsRegex.test(params.realpath))\n        {\n            return {\n                action:     algorithmConfig.writeFile_NTFS.action,\n                message:    _(\"File write - Writing NTFS alternative data streams\", [params.realpath]),\n                confidence: 95,\n                algorithm:  'writeFile_NTFS'\n            }\n        }\n    }\n\n    // PUT 上传脚本文件 - 有个关联问题需要解决，暂时注释掉\n    // if (context.method == 'put' &&\n    //     algorithmConfig.writeFile_PUT_script.action != 'ignore')\n    // {\n    //     if (scriptFileRegex.test(params.realpath))\n    //     {\n    //         return {\n    //             action:     algorithmConfig.writeFile_PUT_script.action,\n    //             message:    _(\"File upload - Using HTTP PUT method to upload a webshell\", [params.realpath]),\n    //             confidence: 95,\n    //             algorithm:  'writeFile_PUT_script'\n    //         }\n    //     }\n    // }\n\n    // 关于这个算法，请参考这个插件定制文档\n    // https://rasp.baidu.com/doc/dev/official.html#case-file-write\n    if (algorithmConfig.writeFile_script.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n        var is_win = context.server.os.indexOf('Windows') != -1\n        if (scriptFileRegex.test(params.realpath))\n        {\n            if (!(algorithmConfig.writeFile_script.userinput) ||\n                ((algorithmConfig.writeFile_script.userinput) &&\n                (is_path_endswith_userinput(all_parameter, params.path, params.realpath, is_win, algorithmConfig.writeFile_script.lcs_search)))\n            ) {\n                return {\n                    action:     algorithmConfig.writeFile_script.action,\n                    message:    _(\"File write - Creating or appending to a server-side script file, file is %1%\", [params.realpath]),\n                    confidence: 85,\n                    algorithm:  'writeFile_script'\n                }\n            }\n        }\n    }\n\n    return clean\n})\n\nplugin.register('deleteFile', function (params, context) {\n\n    if (algorithmConfig.deleteFile_userinput.action != 'ignore')\n    {\n        var all_parameter = get_all_parameter(context)\n        var is_win = context.server.os.indexOf('Windows') != -1\n        if (is_path_endswith_userinput(all_parameter, params.path, params.realpath, is_win, algorithmConfig.deleteFile_userinput.lcs_search)) {\n            return {\n                action:     algorithmConfig.deleteFile_userinput.action,\n                message:    _(\"File delete - Deleting files specified by userinput, file is %1%\", [params.realpath]),\n                confidence: 85,\n                algorithm:  'deleteFile_userinput'\n            }\n        }\n    }\n    return clean\n})\n\n\nplugin.register('fileUpload', function (params, context) {\n\n    // 是否禁止使用 multipart 上传脚本文件，或者 apache/php 服务器配置文件\n    if (algorithmConfig.fileUpload_multipart_script.action != 'ignore')\n    {\n        if (scriptFileRegex.test(params.filename) || ntfsRegex.test(params.filename))\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_script.action,\n                message:    _(\"File upload - Uploading a server-side script file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 95,\n                algorithm:  'fileUpload_multipart_script'\n            }\n        }\n\n        if (params.filename == \".htaccess\" || params.filename == \".user.ini\")\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_script.action,\n                message:    _(\"File upload - Uploading a server-side config file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 95,\n                algorithm:  'fileUpload_multipart_script'\n            }\n        }\n    }\n\n    // 是否禁止 HTML/JS 文件，主要是对抗钓鱼、CORS绕过等问题\n    if (algorithmConfig.fileUpload_multipart_html.action != 'ignore')\n    {\n        if (htmlFileRegex.test(params.filename))\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_html.action,\n                message:    _(\"File upload - Uploading a HTML/JS file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 90,\n                algorithm:  'fileUpload_multipart_html'\n            }\n        }\n    }\n\n    // 是否禁止 EXE/DLL 文件，防止被用于后门下载站点\n    if (algorithmConfig.fileUpload_multipart_exe.action != 'ignore')\n    {\n        if (exeFileRegex.test(params.filename))\n        {\n            return {\n                action:     algorithmConfig.fileUpload_multipart_exe.action,\n                message:    _(\"File upload - Uploading a Executable file with multipart/form-data protocol, filename: %1%\", [params.filename]),\n                confidence: 90,\n                algorithm:  'fileUpload_multipart_exe'\n            }\n        }\n    }\n\n    return clean\n})\n\n\n\nif (algorithmConfig.fileUpload_webdav.action != 'ignore')\n{\n    plugin.register('webdav', function (params, context) {\n\n        // 源文件不是脚本 && 目标文件是脚本，判定为MOVE方式写后门\n        if (! scriptFileRegex.test(params.source) && scriptFileRegex.test(params.dest))\n        {\n            return {\n                action:    algorithmConfig.fileUpload_webdav.action,\n                message:   _(\"File upload - Uploading a server-side script file with HTTP method %1%, file is %2%\", [\n                    context.method, params.dest\n                ]),\n                confidence: 100,\n                algorithm:  'fileUpload_webdav'\n            }\n        }\n\n        return clean\n    })\n}\n\nif (algorithmConfig.rename_webshell.action != 'ignore')\n{\n    plugin.register('rename', function (params, context) {\n        // 目标文件在webroot内才认为是写后门\n        if (!is_outside_webroot(context.appBasePath, params.dest, null)) {\n            // 源文件是干净的文件，目标文件是脚本文件，判定为重命名方式写后门\n            if (cleanFileRegex.test(params.source) && scriptFileRegex.test(params.dest))\n            {\n                return {\n                    action:    algorithmConfig.rename_webshell.action,\n                    message:   _(\"File upload - Renaming a non-script file to server-side script file, source file is %1%\", [\n                        params.source\n                    ]),\n                    confidence: 90,\n                    algorithm:  'rename_webshell'\n                }\n            }\n        }\n\n        return clean\n    })\n}\n\n\nplugin.register('command', function (params, context) {\n    var cmd        = params.command\n    var server     = context.server\n    var message    = undefined\n    var raw_tokens = []\n\n\n    // 算法1: 根据堆栈，检查是否为反序列化攻击。\n    // 理论上，此算法不存在误报\n\n    if (algorithmConfig.command_reflect.action != 'ignore') {\n        // Java 检测逻辑\n        if (server.language == 'java') {\n            var known    = {\n                'com.thoughtworks.xstream.XStream.unmarshal':                                   _(\"Reflected command execution - Using xstream library\"),\n                'java.beans.XMLDecoder.readObject':                                             _(\"Reflected command execution - Using WebLogic XMLDecoder library\"),\n                'org.apache.commons.collections4.functors.InvokerTransformer.transform':        _(\"Reflected command execution - Using Transformer library (v4)\"),\n                'org.apache.commons.collections.functors.InvokerTransformer.transform':         _(\"Reflected command execution - Using Transformer library\"),\n                'org.apache.commons.collections.functors.ChainedTransformer.transform':         _(\"Reflected command execution - Using Transformer library\"),\n                'org.jolokia.jsr160.Jsr160RequestDispatcher.dispatchRequest':                   _(\"Reflected command execution - Using JNDI library (JSR 160)\"),\n                'com.sun.jndi.rmi.registry.RegistryContext.lookup':                             _(\"Reflected command execution - Using JNDI registry service\"),\n                'com.sun.jndi.url.ldap.ldapURLContext.lookup':                                  _(\"Reflected command execution - Using LDAP factory service\"),\n                'com.alibaba.fastjson.JSON.parseObject':                                        _(\"Reflected command execution - Using fastjson library\"),\n                'org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute': _(\"Reflected command execution - Using SpEL expressions\"),\n                'freemarker.template.utility.Execute.exec':                                     _(\"Reflected command execution - Using FreeMarker template\"),\n                'org.jboss.el.util.ReflectionUtil.invokeMethod':                                _(\"Reflected command execution - Using JBoss EL method\"),\n                'net.rebeyond.behinder.payload.java.Cmd.RunCMD':                                _(\"Reflected command execution - Using BeHinder defineClass webshell\"),\n                'org.codehaus.groovy.runtime.ProcessGroovyMethods.execute':                     _(\"Reflected command execution - Using Groovy library\"),\n                'bsh.Reflect.invokeMethod':                                                     _(\"Reflected command execution - Using BeanShell library\"),\n                'jdk.scripting.nashorn/jdk.nashorn.internal.runtime.ScriptFunction.invoke':     _(\"Reflected Command execution - Using Nashorn engine\")\n            }\n\n            var userCode = false, reachedInvoke = false, i = 0\n\n            // v1.1.1 要求在堆栈里过滤 com.baidu.openrasp 相关的类，因为没有实现正确而产生了多余的反射堆栈，这里需要兼容下防止误报\n            // v1.1.2 修复了这个问题，即堆栈顶部为命令执行的方法\n            if (params.stack.length > 3\n                && params.stack[0].startsWith('sun.reflect.GeneratedMethodAccessor')\n                && params.stack[1] == 'sun.reflect.GeneratedMethodAccessorImpl.invoke'\n                && params.stack[2] == 'java.lang.reflect.Method.invoke')\n            {\n                i = 3\n            }\n\n            for (; i < params.stack.length; i ++) {\n                var method = params.stack[i]                \n\n                // 检查反射调用 -> 命令执行之间，是否包含用户代码\n                if (! reachedInvoke) {\n                    if (method == 'java.lang.reflect.Method.invoke') {\n                        reachedInvoke = true\n                    }\n\n                    // 用户代码，即非 JDK、com.baidu.openrasp 相关的函数\n                    if (! method.startsWith('java.') \n                        && ! method.startsWith('sun.') \n                        && !method.startsWith('com.sun.') \n                        && !method.startsWith('com.baidu.openrasp.')) \n                    {\n                        userCode = true\n                    }\n                }\n\n                if (method.startsWith('ysoserial.Pwner')) {\n                    message = _(\"Reflected command execution - Using YsoSerial tool\")\n                    break\n                }\n\n                if (method.startsWith('com.fasterxml.jackson.databind.')) {\n                    message = _(\"Reflected command execution - Using Jackson deserialze method\")\n                    break\n                }\n\n                // 对于如下类型的反射调用:\n                // 1. 仅当命令直接来自反射调用才拦截\n                // 2. 如果某个类是反射生成，这个类再主动执行命令，则忽略\n                if (! userCode) {\n                    if (method == 'ognl.OgnlRuntime.invokeMethod') {\n                        message = _(\"Reflected command execution - Using OGNL library\")\n                        break\n                    }  else if (method == 'java.lang.reflect.Method.invoke') {\n                        message = _(\"Reflected command execution - Unknown vulnerability detected\")\n                        break\n                    }\n                }                                       \n                \n                if (known[method]) {\n                    message = known[method]\n                }\n            }\n        }\n\n        // PHP 检测逻辑\n        else if (server.language == 'php' && validate_stack_php(params.stack))\n        {\n            message = _(\"WebShell activity - Detected reflected command execution\")\n        }\n\n        if (message)\n        {\n            return {\n                action:     algorithmConfig.command_reflect.action,\n                message:    message,\n                confidence: 100,\n                algorithm:  'command_reflect'\n            }\n        }\n    }\n\n    // 从 v0.31 开始，当命令执行来自非HTTP请求的，我们也会检测反序列化攻击\n    // 但是不应该拦截正常的命令执行，所以这里加一个 context.url 检查\n    if (! context.url) {\n        return clean\n    }\n\n    // 算法2: 检测命令注入，或者命令执行后门\n    if (algorithmConfig.command_userinput.action != 'ignore') {\n        var reason     = false\n        var min_length = algorithmConfig.command_userinput.min_length\n        var parameters = context.parameter || {}\n        var json_parameters = context.json || {}\n\n        // 检查命令逻辑是否被用户参数所修改\n        function _run(values, name)\n        {\n            var reason = false\n\n            values.some(function (value) {\n                if (value.length <= min_length) {\n                    return false\n                }\n\n                // 检查用户输入是否存在于命令中\n                var userinput_idx = cmd.indexOf(value)\n                if (userinput_idx == -1) {\n                    return false\n                }\n\n                if (cmd.length == value.length) {\n                    reason = _(\"WebShell detected - Executing command: %1%\", [cmd])\n                    return true\n                }\n                \n                // 懒加载，需要的时候初始化 token\n                if (raw_tokens.length == 0) {\n                    raw_tokens = RASP.cmd_tokenize(cmd)\n                }\n\n                if (is_token_changed(raw_tokens, userinput_idx, value.length)) {\n                    reason = _(\"Command injection - command structure altered by user input, request parameter name: %1%, value: %2%\", [name, value])\n                    return true\n                }\n            })\n\n            return reason\n        }\n\n        // 匹配 GET/POST/multipart 参数\n        Object.keys(parameters).some(function (name) {\n            // 覆盖场景，后者仅PHP支持\n            // ?id=XXXX\n            // ?data[key1][key2]=XXX\n            var value_list = []\n            Object.values(parameters[name]).forEach(function (value){\n                if (typeof value == 'string') {\n                    value_list.push(value)\n                } else {\n                    value_list = value_list.concat(Object.values(value))\n                }\n            })\n            reason = _run(value_list, name)\n            if (reason) {\n                return true\n            }\n        })\n        // 匹配 header 参数\n        if (reason == false && context.header != null) {\n            Object.keys(context.header).some(function (name) {\n                if ( name.toLowerCase() == \"cookie\") {\n                    var cookies = get_cookies(context.header.cookie)\n                    for (name in cookies) {\n                        reason = _run([cookies[name]], \"cookie:\" + name)\n                        if (reason) {\n                            return true\n                        }\n                    }\n                }\n                else if ( headerInjection.indexOf(name.toLowerCase()) != -1) {\n                    reason = _run([context.header[name]], \"header:\" + name)\n                    if (reason) {\n                        return true\n                    }\n                }\n                \n            })\n        }\n\n        // 匹配json参数\n        if (reason == false && Object.keys(json_parameters).length > 0) {\n            var jsons = [ [json_parameters, \"input_json\"] ]\n            while (jsons.length > 0 && reason === false) {\n                var json_arr = jsons.pop()\n                var crt_json_key = json_arr[1]\n                var json_obj = json_arr[0]\n                for (item in json_obj) {\n                    if (typeof json_obj[item] == \"string\") {\n                        reason = _run([json_obj[item]], crt_json_key + \"->\" + item)\n                        if(reason !== false) {\n                            break;\n                        }\n                    }\n                    else if (typeof json_obj[item] == \"object\") {\n                        jsons.push([json_obj[item], crt_json_key + \"->\" + item])\n                    }\n                }\n            }\n        }\n\n        if (reason !== false)\n        {\n            return {\n                action:     algorithmConfig.command_userinput.action,\n                confidence: 90,\n                message:    reason,\n                algorithm:  'command_userinput'\n            }\n        }\n    }\n\n    // 算法3: 常用渗透命令\n    if (algorithmConfig.command_common.action != 'ignore')\n    {\n        var reason = false\n        if (cmdPostPattern.test(params.command))\n        {           \n            return {\n                action:     algorithmConfig.command_common.action,\n                message:    _(\"Webshell detected - Executing potentially dangerous command, command is %1%\", [params.command]),\n                confidence: 95,\n                algorithm:  'command_common'\n            }\n        }     \n    }\n\n    // 算法4: 查找语法错误和敏感操作\n    if (algorithmConfig.command_error.action != 'ignore') {\n        if (raw_tokens.length == 0) {\n            raw_tokens = RASP.cmd_tokenize(cmd)\n        }\n        var concat_char = algorithmConfig.command_error.concat_char\n        var sensitive_cmd = algorithmConfig.command_error.sensitive_cmd\n        var alarm_token = algorithmConfig.command_error.alarm_token\n\n        var double_quote = 0\n        var ticks = 0\n        for (var i=0; i<raw_tokens.length; i++) {\n            if (alarm_token.indexOf(raw_tokens[i].text) != -1) {\n                if ( !(i > 0 && i < raw_tokens.length-1 && raw_tokens[i-1].text == '\"' && raw_tokens[i+1].text == '\"')) {\n                    return {\n                        action:     algorithmConfig.command_error.action,\n                        confidence: 90,\n                        message:    _(\"Command execution - Sensitive command token detect: %1%\", [raw_tokens[i].text]),\n                        algorithm:  'command_error'\n                    }\n                }\n            }\n\n            if (raw_tokens[i+1] !== undefined &&\n                concat_char.indexOf(raw_tokens[i].text) != -1 &&\n                sensitive_cmd.indexOf(raw_tokens[i+1].text) != -1) {\n                return {\n                    action:     algorithmConfig.command_error.action,\n                    confidence: 70,\n                    message:    _(\"Command execution - Sensitive command concat detect: %1% %2%\", [raw_tokens[i].text], raw_tokens[i+1].text),\n                    algorithm:  'command_error'\n                }\n            }\n            if (raw_tokens[i].text == \"\\\"\") {\n                double_quote ++\n            }\n            else if (raw_tokens[i].text == \"`\") {\n                ticks ++\n            }\n        }\n        if (double_quote % 2 != 0) {\n            return {\n                action:     algorithmConfig.command_error.action,\n                confidence: 70,\n                message:    _(\"Command execution - Detected unbalanced double quote!\"),\n                algorithm:  'command_error'\n            }\n        }\n        if (ticks % 2 != 0) {\n            return {\n                action:     algorithmConfig.command_error.action,\n                confidence: 70,\n                message:    _(\"Command execution - Detected unbalanced backtick!\"),\n                algorithm:  'command_error'\n            }\n        }\n    }\n\n    // 算法5: 记录所有的命令执行\n    if (algorithmConfig.command_other.action != 'ignore') \n    {\n        return {\n            action:     algorithmConfig.command_other.action,\n            message:    _(\"Command execution - Logging all command execution by default, command is %1%\", [params.command]),\n            confidence: 90,\n            algorithm:  'command_other'\n        }\n    }\n\n    return clean\n})\n\n\n// 注意: 由于libxml2无法挂钩，所以PHP暂时不支持XXE检测\nplugin.register('xxe', function (params, context) {\n    var server    = context.server\n    var is_win    = server.os.indexOf('Windows') != -1\n    var items     = params.entity.split('://')\n\n    if (algorithmConfig.xxe_protocol.action != 'ignore') {\n        // 检查 windows + SMB 协议，防止泄露 NTLM 信息\n        if (params.entity.startsWith('\\\\\\\\')) {\n            return {\n                action:     algorithmConfig.xxe_protocol.action,\n                message:    _(\"XXE - Using dangerous protocol SMB\"),\n                confidence: 100,\n                algorithm:  'xxe_protocol'\n            }\n        }\n    }\n\n    if (items.length >= 2) {\n        var protocol = items[0].toLowerCase()\n        var address  = items[1]\n\n        // 拒绝特殊协议\n        if (algorithmConfig.xxe_protocol.action != 'ignore') {\n            if (algorithmConfig.xxe_protocol.protocols.indexOf(protocol) != -1) {\n                return {\n                    action:     algorithmConfig.xxe_protocol.action,\n                    message:    _(\"XXE - Using dangerous protocol %1%\", [protocol]),\n                    confidence: 100,\n                    algorithm:  'xxe_protocol'\n                }\n            }\n\n        }\n\n        // file 协议 + 绝对路径, e.g\n        // file:///etc/passwd\n        // file:///etc/passwd?a=1#b=2 (仅Java支持)\n        //\n        // 相对路径容易误报, e.g\n        // file://xwork.dtd\n        if (algorithmConfig.xxe_file.action != 'ignore')\n        {\n            if (address.length > 0 && protocol === 'file' && is_absolute_path(address, is_win) )\n            {\n                var address_lc = address.toLowerCase()\n                \n                // 1.0 Rhino 引擎不支持URL对象，考虑到 1.0 用户不多，先简单处理下\n                try\n                {\n                    var urlObj = new URL(address_lc)\n                    address_lc = urlObj.pathname\n                }\n                catch (e) {}\n\n                // 过滤掉 xml、dtd\n                if (! address_lc.endsWith('.xml') &&\n                    ! address_lc.endsWith('.dtd'))\n                {\n                    return {\n                        action:     algorithmConfig.xxe_file.action,\n                        message:    _(\"XXE - Accessing file %1%\", [address]),\n                        confidence: 90,\n                        algorithm:  'xxe_file'\n                    }\n                }\n            }\n        }\n\n    }\n    return clean\n})\n\n\nif (algorithmConfig.eval_regex.action != 'ignore')\n{\n\t// 算法1: 正则表达式\n    plugin.register('eval', function(params, context) {\n        var regex_filter = new RegExp(algorithmConfig.eval_regex.regex, 'i')\n            \n        if (regex_filter.test(params.code)) {\n\n        \t// 避免 message 太长\n        \tvar code = params.code.substr(0, 50)\n        \tif (params.code.length > 50)\n        \t{\n        \t\tcode = code + ' ...'\n        \t}\n\n            return {\n                action:     algorithmConfig.eval_regex.action,\n                confidence: 60,\n                message:    _(\"Code Execution - Running %1% with %2%() function\", [code, params.function]),\n                algorithm:  'eval_regex'\n            }\n        }\n    })\n}\n\nplugin.register('loadLibrary', function(params, context) {\n\n    if (algorithmConfig.loadLibrary_unc.action != 'ignore') {\n\n        // 仅 windows 需要检查 UNC\n        var is_windows = context.server.os.indexOf('Windows') != -1\n        if (is_windows) {\n            if (params.path.startsWith('\\\\\\\\') || params.path.startsWith('//')) {\n                return {\n                    action:     algorithmConfig.loadLibrary_unc.action,\n                    confidence: 60,\n                    message:    _(\"Load library in UNC path - loading %1% with %2%() function\", [params.path, params.function]),\n                    algorithm:  'loadLibrary_unc'\n                }\n            }    \n        }\n        \n    }\n\n    // if (algorithmConfig.loadLibrary_other.action != 'ignore') {\n    //     return {\n    //         action:     algorithmConfig.loadLibrary_other.action,\n    //         confidence: 60,\n    //         message:    _(\"Load library - logging all by default, library path is %1%\", [params.path]),\n    //         algorithm:  'loadLibrary_other'\n    //     }     \n    // }\n\n    return clean\n})\n\nif (algorithmConfig.ognl_exec.action != 'ignore')\n{\n    // 默认情况下，当OGNL表达式长度超过30才会进入检测点，此长度可配置\n    plugin.register('ognl', function (params, context) {\n\n        // 常见 struts payload 语句特征\n        var ognlPayloads = [\n            'ognl.OgnlContext',\n            'ognl.TypeConverter',\n            'ognl.MemberAccess',\n            '_memberAccess',\n            'ognl.ClassResolver',\n            'java.lang.Runtime',\n            'java.lang.Class',\n            'java.lang.ClassLoader',\n            'java.lang.System',\n            'java.lang.ProcessBuilder',\n            'java.lang.Object',\n            'java.lang.Shutdown',\n            'java.io.File',\n            'javax.script.ScriptEngineManager',\n            'com.opensymphony.xwork2.ActionContext'\n        ]\n\n        var ognlExpression = params.expression\n        for (var index in ognlPayloads)\n        {\n            if (ognlExpression.indexOf(ognlPayloads[index]) > -1)\n            {\n                return {\n                    action:     algorithmConfig.ognl_exec.action,\n                    message:    _(\"OGNL exec - Trying to exploit a OGNL expression vulnerability\"),\n                    confidence: 100,\n                    algorithm:  'ognl_exec'\n                }\n            }\n\n        }\n        return clean\n    })\n}\n\nif (algorithmConfig.deserialization_transformer.action != 'ignore') {\n\n    plugin.register('deserialization', function (params, context) {\n        var deserializationInvalidClazz = [\n            'org.apache.commons.collections.functors.ChainedTransformer.transform',\n            'org.apache.commons.collections.functors.InvokerTransformer',\n            'org.apache.commons.collections.functors.InstantiateTransformer',\n            'org.apache.commons.collections4.functors.InvokerTransformer',\n            'org.apache.commons.collections4.functors.InstantiateTransformer',\n            'org.codehaus.groovy.runtime.ConvertedClosure',\n            'org.codehaus.groovy.runtime.MethodClosure',\n            'org.springframework.beans.factory.ObjectFactory',\n            'xalan.internal.xsltc.trax.TemplatesImpl'\n        ]\n\n        var clazz = params.clazz\n        for (var index in deserializationInvalidClazz) {\n            if (clazz === deserializationInvalidClazz[index]) {\n                return {\n                    action:     algorithmConfig.deserialization_transformer.action,\n                    message:    _(\"Transformer deserialization - unknown deserialize vulnerability detected\"),\n                    confidence: 100,\n                    algorithm:  'deserialization_transformer'\n                }\n            }\n        }\n        return clean\n    })\n}\n\n\n// 匹配身份证\nfunction findFirstIdentityCard(data) {\n    const regexChineseId = /(?<!\\d)\\d{10}(?:[01]\\d)(?:[0123]\\d)\\d{3}(?:\\d|x|X)(?!\\d)/;\n    const W = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\n    const m = regexChineseId.exec(data)\n    if (m) {\n        const id = m[0]\n        let sum = 0;\n        for (let i = 0; i < W.length; i++) {\n            sum += (id[i] - '0') * W[i];\n        }\n        if (id[17] == 'X' || id[17] == 'x') {\n            sum += 10;\n        } else {\n            sum += id[17] - '0';\n        }\n        if (sum % 11 == 1) {\n            return {\n                type:  'Identity Card',\n                match: m[0],\n                parts: data.slice(Math.max(m.index - 40, 0), m.index + m[0].length + 40)\n            }\n        }\n    }\n}\n\n// 匹配手机号\nfunction findFirstMobileNumber(data) {\n    const regexChinesePhone = /(?<!\\d)(?:(?:00|\\+)?86 ?)?(1\\d{2})(?:[ -]?\\d){8}(?!\\d)/;\n    const prefixs = new Set([133, 149, 153, 173, 174, 177, 180,\n        181, 189, 199, 130, 131, 132, 145, 146, 155, 156, 166, 175, 176, 185, 186, 134, 135, 136, 137, 138, 139,\n        147, 148, 150, 151, 152, 157, 158, 159, 165, 178, 182, 183, 184, 187, 188, 198, 170\n    ]);\n    let m = regexChinesePhone.exec(data)\n    if (m) {\n        if (prefixs.has(parseInt(m[1]))) {\n            return {\n                type:  'Mobile Number',\n                match: m[0],\n                parts: data.slice(Math.max(m.index - 40, 0), m.index + m[0].length + 40)\n            }\n        }\n    }\n}\n\n// 匹配银行卡、信用卡\nfunction findFirstBankCard(data) {\n    const regexBankCard = /(?<!\\d)(?:62|3|5[1-5]|4\\d)\\d{2}(?:[ -]?\\d{4}){3}(?!\\d)/;\n    let m = regexBankCard.exec(data)\n    if (m) {\n        let card = m[0].replace(/ |-/g, \"\");\n        let len = card.length;\n        let sum = 0;\n        for (let i = len; i >= 1; i--) {\n            let t = card[len - i] - '0';\n            if (i % 2 == 0) {\n                t *= 2;\n            }\n            sum = sum + Math.floor(t / 10) + t % 10;\n        }\n        if (sum % 10 == 0) {\n            return {\n                type:  'Bank Card',\n                match: m[0],\n                parts: data.slice(Math.max(m.index - 40, 0), m.index + m[0].length + 40)\n            }\n        }\n    }\n}\n\nif (algorithmConfig.response_dataLeak.action != 'ignore') {\n\n    // response 所有检测点都会抽样\n    plugin.register('response', function (params, context) {\n        const content_type = params.content_type\n        const content      = params.content\n        const kind         = algorithmConfig.response_dataLeak.kind\n        const header       = context.header || {}\n\n        var items = [], parts = []\n\n        // content-type 过滤\n        if ( ! content_type && ! dataLeakContentType.test(content_type)) {\n            return clean\n        }\n\n        // 是否检查身份证泄露\n        if (kind.identity_card) {\n            const data = findFirstIdentityCard(content)\n            if (data) {\n                items.push(data.match + '(' + data.type + ')')\n                parts.push(data)\n            }\n        }\n\n        // 是否检查手机号泄露\n        if (kind.phone) {\n            const data = findFirstMobileNumber(content)\n            if (data) {\n                items.push(data.match + '(' + data.type + ')')\n                parts.push(data)\n            }\n        }\n\n        // 是否检查银行卡泄露\n        if (kind.bank_card) {\n            const data = findFirstBankCard(content)\n            if (data) {\n                items.push(data.match + '(' + data.type + ')')\n                parts.push(data)\n            }\n        }\n\n        if (items.length) {\n            return {\n                action:     algorithmConfig.response_dataLeak.action,\n                message:    'PII leak detected: ' + items.join('、 '),\n                confidence: 80,\n                algorithm:  'response_dataLeak',\n                params: {\n                    parts\n                }\n            }\n        }\n    })\n\n}\n\nplugin.log('OpenRASP official plugin: Initialized, version', plugin_version)\n\n"
        }
    },
    "description": "ok",
    "status": 0
}